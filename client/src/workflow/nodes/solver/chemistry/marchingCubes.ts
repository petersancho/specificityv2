/**
 * Marching Cubes Algorithm - PhD-Level Implementation
 * 
 * Extracts smooth isosurfaces from scalar fields using proper edge interpolation.
 * Based on Lorensen & Cline (1987) "Marching Cubes: A High Resolution 3D Surface Construction Algorithm"
 * 
 * This implementation:
 * - Uses proper edge interpolation (not cell-center approximation)
 * - Implements full 256-case lookup table
 * - Generates smooth, manifold surfaces
 * - Computes proper vertex normals from gradient field
 * - Supports material concentration blending at interpolated vertices
 * 
 * Philosophy: Pure TypeScript. No external libraries. Built from first principles.
 */

export type Vec3 = { x: number; y: number; z: number };

export type VoxelField = {
  resolution: number;
  bounds: { min: Vec3; max: Vec3 };
  cellSize: Vec3;
  data: Float32Array[]; // Material concentrations
  densities: Float32Array; // Scalar field for isosurface
};

export type MarchingCubesMesh = {
  positions: number[];
  normals: number[];
  colors: number[];
  indices: number[];
  uvs: number[];
};

// ═══════════════════════════════════════════════════════════════════════════
// EDGE TABLE - Which edges are intersected for each cube configuration
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Edge table: 256 entries (one per cube configuration)
 * Each entry is a 12-bit mask indicating which edges are intersected
 * 
 * Edge numbering:
 *   0: (0,0,0) -> (1,0,0)
 *   1: (1,0,0) -> (1,1,0)
 *   2: (1,1,0) -> (0,1,0)
 *   3: (0,1,0) -> (0,0,0)
 *   4: (0,0,1) -> (1,0,1)
 *   5: (1,0,1) -> (1,1,1)
 *   6: (1,1,1) -> (0,1,1)
 *   7: (0,1,1) -> (0,0,1)
 *   8: (0,0,0) -> (0,0,1)
 *   9: (1,0,0) -> (1,0,1)
 *  10: (1,1,0) -> (1,1,1)
 *  11: (0,1,0) -> (0,1,1)
 */
const EDGE_TABLE: number[] = [
  0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
  0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
  0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
  0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
  0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c,
  0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
  0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,
  0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
  0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c,
  0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
  0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc,
  0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
  0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c,
  0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
  0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc,
  0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
  0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
  0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
  0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
  0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
  0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
  0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
  0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
  0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,
  0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
  0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,
  0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
  0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,
  0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
  0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,
  0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
  0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
];


// ═══════════════════════════════════════════════════════════════════════════
// TRIANGLE TABLE - Which triangles to generate for each cube configuration
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Triangle table: 256 entries (one per cube configuration)
 * Each entry lists the edges that form triangles (in groups of 3)
 * -1 terminates the list
 * 
 * Maximum 5 triangles per cube (15 edges)
 */
const TRI_TABLE: number[][] = [
  [],
  [0, 8, 3],
  [0, 1, 9],
  [1, 8, 3, 9, 8, 1],
  [1, 2, 10],
  [0, 8, 3, 1, 2, 10],
  [9, 2, 10, 0, 2, 9],
  [2, 8, 3, 2, 10, 8, 10, 9, 8],
  [3, 11, 2],
  [0, 11, 2, 8, 11, 0],
  [1, 9, 0, 2, 3, 11],
  [1, 11, 2, 1, 9, 11, 9, 8, 11],
  [3, 10, 1, 11, 10, 3],
  [0, 10, 1, 0, 8, 10, 8, 11, 10],
  [3, 9, 0, 3, 11, 9, 11, 10, 9],
  [9, 8, 10, 10, 8, 11],
  [4, 7, 8],
  [4, 3, 0, 7, 3, 4],
  [0, 1, 9, 8, 4, 7],
  [4, 1, 9, 4, 7, 1, 7, 3, 1],
  [1, 2, 10, 8, 4, 7],
  [3, 4, 7, 3, 0, 4, 1, 2, 10],
  [9, 2, 10, 9, 0, 2, 8, 4, 7],
  [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4],
  [8, 4, 7, 3, 11, 2],
  [11, 4, 7, 11, 2, 4, 2, 0, 4],
  [9, 0, 1, 8, 4, 7, 2, 3, 11],
  [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1],
  [3, 10, 1, 3, 11, 10, 7, 8, 4],
  [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4],
  [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3],
  [4, 7, 11, 4, 11, 9, 9, 11, 10],
  [9, 5, 4],
  [9, 5, 4, 0, 8, 3],
  [0, 5, 4, 1, 5, 0],
  [8, 5, 4, 8, 3, 5, 3, 1, 5],
  [1, 2, 10, 9, 5, 4],
  [3, 0, 8, 1, 2, 10, 4, 9, 5],
  [5, 2, 10, 5, 4, 2, 4, 0, 2],
  [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8],
  [9, 5, 4, 2, 3, 11],
  [0, 11, 2, 0, 8, 11, 4, 9, 5],
  [0, 5, 4, 0, 1, 5, 2, 3, 11],
  [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5],
  [10, 3, 11, 10, 1, 3, 9, 5, 4],
  [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10],
  [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3],
  [5, 4, 8, 5, 8, 10, 10, 8, 11],
  [9, 7, 8, 5, 7, 9],
  [9, 3, 0, 9, 5, 3, 5, 7, 3],
  [0, 7, 8, 0, 1, 7, 1, 5, 7],
  [1, 5, 3, 3, 5, 7],
  [9, 7, 8, 9, 5, 7, 10, 1, 2],
  [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3],
  [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2],
  [2, 10, 5, 2, 5, 3, 3, 5, 7],
  [7, 9, 5, 7, 8, 9, 3, 11, 2],
  [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11],
  [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7],
  [11, 2, 1, 11, 1, 7, 7, 1, 5],
  [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11],
  [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0],
  [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0],
  [11, 10, 5, 7, 11, 5],
  [10, 6, 5],
  [0, 8, 3, 5, 10, 6],
  [9, 0, 1, 5, 10, 6],
  [1, 8, 3, 1, 9, 8, 5, 10, 6],
  [1, 6, 5, 2, 6, 1],
  [1, 6, 5, 1, 2, 6, 3, 0, 8],
  [9, 6, 5, 9, 0, 6, 0, 2, 6],
  [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8],
  [2, 3, 11, 10, 6, 5],
  [11, 0, 8, 11, 2, 0, 10, 6, 5],
  [0, 1, 9, 2, 3, 11, 5, 10, 6],
  [5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11],
  [6, 3, 11, 6, 5, 3, 5, 1, 3],
  [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6],
  [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9],
  [6, 5, 9, 6, 9, 11, 11, 9, 8],
  [5, 10, 6, 4, 7, 8],
  [4, 3, 0, 4, 7, 3, 6, 5, 10],
  [1, 9, 0, 5, 10, 6, 8, 4, 7],
  [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4],
  [6, 1, 2, 6, 5, 1, 4, 7, 8],
  [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7],
  [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6],
  [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9],
  [3, 11, 2, 7, 8, 4, 10, 6, 5],
  [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11],
  [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6],
  [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6],
  [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6],
  [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11],
  [0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7],
  [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9],
  [10, 4, 9, 6, 4, 10],
  [4, 10, 6, 4, 9, 10, 0, 8, 3],
  [10, 0, 1, 10, 6, 0, 6, 4, 0],
  [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10],
  [1, 4, 9, 1, 2, 4, 2, 6, 4],
  [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4],
  [0, 2, 4, 4, 2, 6],
  [8, 3, 2, 8, 2, 4, 4, 2, 6],
  [10, 4, 9, 10, 6, 4, 11, 2, 3],
  [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6],
  [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10],
  [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1],
  [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3],
  [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1],
  [3, 11, 6, 3, 6, 0, 0, 6, 4],
  [6, 4, 8, 11, 6, 8],
  [7, 10, 6, 7, 8, 10, 8, 9, 10],
  [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10],
  [10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0],
  [10, 6, 7, 10, 7, 1, 1, 7, 3],
  [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7],
  [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9],
  [7, 8, 0, 7, 0, 6, 6, 0, 2],
  [7, 3, 2, 6, 7, 2],
  [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7],
  [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7],
  [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11],
  [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1],
  [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6],
  [0, 9, 1, 11, 6, 7],
  [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0],
  [7, 11, 6],
  [7, 6, 11],
  [3, 0, 8, 11, 7, 6],
  [0, 1, 9, 11, 7, 6],
  [8, 1, 9, 8, 3, 1, 11, 7, 6],
  [10, 1, 2, 6, 11, 7],
  [1, 2, 10, 3, 0, 8, 6, 11, 7],
  [2, 9, 0, 2, 10, 9, 6, 11, 7],
  [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8],
  [7, 2, 3, 6, 2, 7],
  [7, 0, 8, 7, 6, 0, 6, 2, 0],
  [2, 7, 6, 2, 3, 7, 0, 1, 9],
  [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6],
  [10, 7, 6, 10, 1, 7, 1, 3, 7],
  [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8],
  [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7],
  [7, 6, 10, 7, 10, 8, 8, 10, 9],
  [6, 8, 4, 11, 8, 6],
  [3, 6, 11, 3, 0, 6, 0, 4, 6],
  [8, 6, 11, 8, 4, 6, 9, 0, 1],
  [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6],
  [6, 8, 4, 6, 11, 8, 2, 10, 1],
  [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6],
  [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9],
  [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3],
  [8, 2, 3, 8, 4, 2, 4, 6, 2],
  [0, 4, 2, 4, 6, 2],
  [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8],
  [1, 9, 4, 1, 4, 2, 2, 4, 6],
  [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1],
  [10, 1, 0, 10, 0, 6, 6, 0, 4],
  [4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3],
  [10, 9, 4, 6, 10, 4],
  [4, 9, 5, 7, 6, 11],
  [0, 8, 3, 4, 9, 5, 11, 7, 6],
  [5, 0, 1, 5, 4, 0, 7, 6, 11],
  [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5],
  [9, 5, 4, 10, 1, 2, 7, 6, 11],
  [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5],
  [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2],
  [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6],
  [7, 2, 3, 7, 6, 2, 5, 4, 9],
  [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7],
  [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0],
  [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8],
  [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7],
  [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4],
  [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10],
  [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10],
  [6, 9, 5, 6, 11, 9, 11, 8, 9],
  [3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5],
  [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11],
  [6, 11, 3, 6, 3, 5, 5, 3, 1],
  [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6],
  [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10],
  [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5],
  [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3],
  [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2],
  [9, 5, 6, 9, 6, 0, 0, 6, 2],
  [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8],
  [1, 5, 6, 2, 1, 6],
  [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6],
  [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0],
  [0, 3, 8, 5, 6, 10],
  [10, 5, 6],
  [11, 5, 10, 7, 5, 11],
  [11, 5, 10, 11, 7, 5, 8, 3, 0],
  [5, 11, 7, 5, 10, 11, 1, 9, 0],
  [10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1],
  [11, 1, 2, 11, 7, 1, 7, 5, 1],
  [0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11],
  [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7],
  [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2],
  [2, 5, 10, 2, 3, 5, 3, 7, 5],
  [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5],
  [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2],
  [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2],
  [1, 3, 5, 3, 7, 5],
  [0, 8, 7, 0, 7, 1, 1, 7, 5],
  [9, 0, 3, 9, 3, 5, 5, 3, 7],
  [9, 8, 7, 5, 9, 7],
  [5, 8, 4, 5, 10, 8, 10, 11, 8],
  [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0],
  [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5],
  [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4],
  [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8],
  [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11],
  [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5],
  [9, 4, 5, 2, 11, 3],
  [2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4],
  [5, 10, 2, 5, 2, 4, 4, 2, 0],
  [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9],
  [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2],
  [8, 4, 5, 8, 5, 3, 3, 5, 1],
  [0, 4, 5, 1, 0, 5],
  [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5],
  [9, 4, 5],
  [4, 11, 7, 4, 9, 11, 9, 10, 11],
  [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11],
  [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11],
  [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4],
  [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2],
  [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3],
  [11, 7, 4, 11, 4, 2, 2, 4, 0],
  [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4],
  [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9],
  [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7],
  [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10],
  [1, 10, 2, 8, 7, 4],
  [4, 9, 1, 4, 1, 7, 7, 1, 3],
  [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1],
  [4, 0, 3, 7, 4, 3],
  [4, 8, 7],
  [9, 10, 8, 10, 11, 8],
  [3, 0, 9, 3, 9, 11, 11, 9, 10],
  [0, 1, 10, 0, 10, 8, 8, 10, 11],
  [3, 1, 10, 11, 3, 10],
  [1, 2, 11, 1, 11, 9, 9, 11, 8],
  [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9],
  [0, 2, 11, 8, 0, 11],
  [3, 2, 11],
  [2, 3, 8, 2, 8, 10, 10, 8, 9],
  [9, 10, 2, 0, 9, 2],
  [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8],
  [1, 10, 2],
  [1, 3, 8, 9, 1, 8],
  [0, 9, 1],
  [0, 3, 8],
  []
];


// ═══════════════════════════════════════════════════════════════════════════
// EDGE VERTEX POSITIONS
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Edge endpoints in cube local coordinates
 * Each edge connects two corners of the unit cube
 */
const EDGE_VERTICES: [number, number][] = [
  [0, 1], [1, 2], [2, 3], [3, 0], // Bottom face
  [4, 5], [5, 6], [6, 7], [7, 4], // Top face
  [0, 4], [1, 5], [2, 6], [3, 7]  // Vertical edges
];

/**
 * Cube corner positions in local coordinates
 */
const CUBE_CORNERS: [number, number, number][] = [
  [0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], // Bottom face (z=0)
  [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]  // Top face (z=1)
];

// ═══════════════════════════════════════════════════════════════════════════
// MARCHING CUBES IMPLEMENTATION
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Linear interpolation between two values
 */
const lerp = (a: number, b: number, t: number): number => {
  return a + (b - a) * t;
};

/**
 * Compute interpolation factor for isosurface crossing
 * 
 * Given two scalar values v1 and v2, and an isovalue,
 * compute where along the edge the isosurface crosses
 */
const computeInterpolationFactor = (
  v1: number,
  v2: number,
  isovalue: number
): number => {
  const epsilon = 1e-6;
  if (Math.abs(v1 - v2) < epsilon) return 0.5;
  return (isovalue - v1) / (v2 - v1);
};

/**
 * Compute gradient at a voxel position using central differences
 * 
 * ∇f = (∂f/∂x, ∂f/∂y, ∂f/∂z)
 * 
 * Central difference: ∂f/∂x ≈ (f(x+h) - f(x-h)) / (2h)
 */
const computeGradient = (
  field: VoxelField,
  x: number,
  y: number,
  z: number
): Vec3 => {
  const res = field.resolution;
  const densities = field.densities;
  
  const idx = (xi: number, yi: number, zi: number): number => {
    const cx = Math.max(0, Math.min(res - 1, xi));
    const cy = Math.max(0, Math.min(res - 1, yi));
    const cz = Math.max(0, Math.min(res - 1, zi));
    return cx + cy * res + cz * res * res;
  };
  
  const dx = (densities[idx(x + 1, y, z)] - densities[idx(x - 1, y, z)]) / 2;
  const dy = (densities[idx(x, y + 1, z)] - densities[idx(x, y - 1, z)]) / 2;
  const dz = (densities[idx(x, y, z + 1)] - densities[idx(x, y, z - 1)]) / 2;
  
  const len = Math.sqrt(dx * dx + dy * dy + dz * dz);
  if (len < 1e-6) return { x: 0, y: 1, z: 0 };
  
  return { x: dx / len, y: dy / len, z: dz / len };
};

/**
 * Extract isosurface from voxel field using Marching Cubes algorithm
 * 
 * @param field - Voxel field with density and material concentration data
 * @param isovalue - Threshold value for isosurface (typically 0.5)
 * @param materialColors - RGB colors for each material [r, g, b] in range [0, 1]
 * @returns Mesh with positions, normals, colors, indices, and UVs
 */
export const marchingCubes = (
  field: VoxelField,
  isovalue: number,
  materialColors: Array<[number, number, number]>
): MarchingCubesMesh => {
  const positions: number[] = [];
  const normals: number[] = [];
  const colors: number[] = [];
  const indices: number[] = [];
  const uvs: number[] = [];
  
  const res = field.resolution;
  const { bounds, cellSize, densities, data: materialData } = field;
  const materialCount = materialData.length;
  
  // Edge vertex cache to avoid duplicate vertices
  // Key: "x,y,z,edge" -> vertex index
  const edgeCache = new Map<string, number>();
  
  /**
   * Get or create vertex at edge intersection
   */
  const getEdgeVertex = (
    x: number,
    y: number,
    z: number,
    edge: number
  ): number => {
    const key = `${x},${y},${z},${edge}`;
    const cached = edgeCache.get(key);
    if (cached !== undefined) return cached;
    
    // Get edge endpoints
    const [v1Idx, v2Idx] = EDGE_VERTICES[edge];
    const [c1x, c1y, c1z] = CUBE_CORNERS[v1Idx];
    const [c2x, c2y, c2z] = CUBE_CORNERS[v2Idx];
    
    // Get voxel indices for corners
    const x1 = x + c1x, y1 = y + c1y, z1 = z + c1z;
    const x2 = x + c2x, y2 = y + c2y, z2 = z + c2z;
    
    const idx1 = x1 + y1 * res + z1 * res * res;
    const idx2 = x2 + y2 * res + z2 * res * res;
    
    const val1 = densities[idx1];
    const val2 = densities[idx2];
    
    // Compute interpolation factor
    const t = computeInterpolationFactor(val1, val2, isovalue);
    
    // Interpolate position
    const px = lerp(
      bounds.min.x + x1 * cellSize.x,
      bounds.min.x + x2 * cellSize.x,
      t
    );
    const py = lerp(
      bounds.min.y + y1 * cellSize.y,
      bounds.min.y + y2 * cellSize.y,
      t
    );
    const pz = lerp(
      bounds.min.z + z1 * cellSize.z,
      bounds.min.z + z2 * cellSize.z,
      t
    );
    
    // Interpolate normal (from gradient)
    const grad1 = computeGradient(field, x1, y1, z1);
    const grad2 = computeGradient(field, x2, y2, z2);
    
    const nx = lerp(grad1.x, grad2.x, t);
    const ny = lerp(grad1.y, grad2.y, t);
    const nz = lerp(grad1.z, grad2.z, t);
    
    const nlen = Math.sqrt(nx * nx + ny * ny + nz * nz);
    const nnx = nlen > 1e-6 ? nx / nlen : 0;
    const nny = nlen > 1e-6 ? ny / nlen : 1;
    const nnz = nlen > 1e-6 ? nz / nlen : 0;
    
    // Interpolate material concentrations
    let r = 0, g = 0, b = 0;
    if (materialCount > 0) {
      for (let m = 0; m < materialCount; m++) {
        const conc1 = materialData[m][idx1] || 0;
        const conc2 = materialData[m][idx2] || 0;
        const conc = lerp(conc1, conc2, t);
        
        r += materialColors[m][0] * conc;
        g += materialColors[m][1] * conc;
        b += materialColors[m][2] * conc;
      }
    } else {
      // No material data - use first material color as default
      r = materialColors[0]?.[0] ?? 0.85;
      g = materialColors[0]?.[1] ?? 0.85;
      b = materialColors[0]?.[2] ?? 0.87;
    }
    
    // Add vertex
    const vertexIndex = positions.length / 3;
    positions.push(px, py, pz);
    normals.push(nnx, nny, nnz);
    colors.push(r, g, b);
    uvs.push(0, 0); // TODO: Compute proper UVs
    
    edgeCache.set(key, vertexIndex);
    return vertexIndex;
  };
  
  // Process each cube in the grid
  for (let z = 0; z < res - 1; z++) {
    for (let y = 0; y < res - 1; y++) {
      for (let x = 0; x < res - 1; x++) {
        // Get density values at 8 cube corners
        const cornerValues: number[] = [];
        for (let i = 0; i < 8; i++) {
          const [cx, cy, cz] = CUBE_CORNERS[i];
          const idx = (x + cx) + (y + cy) * res + (z + cz) * res * res;
          cornerValues.push(densities[idx]);
        }
        
        // Compute cube configuration index (0-255)
        let cubeIndex = 0;
        for (let i = 0; i < 8; i++) {
          if (cornerValues[i] >= isovalue) {
            cubeIndex |= (1 << i);
          }
        }
        
        // Skip if cube is entirely inside or outside
        if (cubeIndex === 0 || cubeIndex === 255) continue;
        
        // Get edge mask for this configuration
        const edgeMask = EDGE_TABLE[cubeIndex];
        if (edgeMask === 0) continue;
        
        // Get vertices for intersected edges
        const edgeVertices: number[] = [];
        for (let i = 0; i < 12; i++) {
          if (edgeMask & (1 << i)) {
            edgeVertices[i] = getEdgeVertex(x, y, z, i);
          }
        }
        
        // Generate triangles from triangle table
        const triangles = TRI_TABLE[cubeIndex];
        for (let i = 0; i < triangles.length; i += 3) {
          const v0 = edgeVertices[triangles[i]];
          const v1 = edgeVertices[triangles[i + 1]];
          const v2 = edgeVertices[triangles[i + 2]];
          
          indices.push(v0, v1, v2);
        }
      }
    }
  }
  
  return { positions, normals, colors, indices, uvs };
};

/**
 * Extract isosurface with simplified interface (for backward compatibility)
 */
export const generateMeshFromField = (
  field: VoxelField,
  isovalue: number,
  materialColors: Array<[number, number, number]>
): MarchingCubesMesh => {
  return marchingCubes(field, isovalue, materialColors);
};
