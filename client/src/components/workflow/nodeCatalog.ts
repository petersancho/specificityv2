import type { NodeType } from "../../workflow/nodeTypes";
import {
  NODE_CATEGORIES,
  NODE_CATEGORY_BY_ID,
  NODE_DEFINITIONS,
  PORT_TYPE_COLOR,
  coerceValueToPortType,
  getDefaultParameters,
  getNodeDefinition,
  isPortTypeCompatible,
  resolveNodeParameters,
  resolveNodePorts,
  resolvePortByKey,
  type NodeCategory,
  type NodeCategoryId,
  type WorkflowNodeDefinition,
  type WorkflowParameterSpec,
  type WorkflowPortSpec,
  type WorkflowPortType,
  type WorkflowValue,
} from "../../workflow/nodeRegistry";

export {
  NODE_CATEGORIES,
  NODE_CATEGORY_BY_ID,
  NODE_DEFINITIONS,
  PORT_TYPE_COLOR,
  coerceValueToPortType,
  getDefaultParameters,
  getNodeDefinition,
  isPortTypeCompatible,
  resolveNodeParameters,
  resolveNodePorts,
  resolvePortByKey,
  type NodeCategory,
  type NodeCategoryId,
  type WorkflowNodeDefinition as NodeDefinition,
  type WorkflowParameterSpec,
  type WorkflowPortSpec,
  type WorkflowPortType,
  type WorkflowValue,
};

/**
 * Comprehensive implementation notes for all Numerica workflow nodes.
 * These notes provide detailed usage guidance displayed in documentation pages.
 */
const NODE_IMPLEMENTATION_NOTES: Partial<Record<NodeType, string>> = {
  // === DATA & UI NODES ===
  geometryReference: "The foundational bridge between Roslyn's direct modeling world and Numerica's parametric graph system. When you select geometry in Roslyn and add this node, you create a live reference that keeps the graph synchronized with your modeled forms. This is the primary entry point for bringing hand-crafted geometry into computational workflows. The reference is persistent—if you modify the Roslyn geometry, all downstream nodes automatically recompute. Think of it as declaring: 'this modeled shape is now a variable in my parametric system.' Use Geometry Reference when you want to apply algorithmic transformations, optimization, or analysis to geometry you've already created through direct manipulation. Multiple references can coexist, letting you combine several Roslyn objects in a single graph.",
  text: "A canvas annotation node that renders handwritten-style text directly on the Numerica workspace. Unlike Panel or Text Note, this node has no data ports—it exists purely for documentation and visual organization. Double-click to edit the content inline. Text nodes are essential for creating readable, self-documenting workflows. Use them to label sections ('INPUT PARAMETERS', 'STRUCTURAL ANALYSIS', 'OUTPUT'), explain complex logic, or leave notes for collaborators. Position text nodes near the nodes they describe. The handwritten aesthetic reinforces that Numerica is a design tool, not just code—your workflows are visual documents that tell a story.",
  group: "An organizational container that visually collects related nodes into a bounded region. Groups serve multiple purposes: they clarify workflow structure by creating named sections, they allow bulk operations (move all grouped nodes together), and they can be collapsed to hide complexity when you need to focus elsewhere. Drag existing nodes into a group, or draw a group around nodes to capture them. Double-click the header bar to rename—good names like 'Facade Parametrics' or 'Structural Goals' make workflows instantly readable. Groups are purely visual; they don't affect data flow. Use them liberally in complex workflows to maintain sanity as node count grows.",
  panel: "The primary debugging and inspection tool in Numerica. Connect any output port to see its live value as formatted text. Numbers display with appropriate precision, vectors show {x, y, z} components, lists display with line numbers for easy element identification, and nested structures expand to show hierarchy. When disconnected, Panel shows editable fallback text—useful for documentation or placeholders. Panel is non-destructive: data passes through unchanged, so you can insert Panels anywhere without breaking downstream connections. Place Panels at critical junctures to verify data flow, inspect solver outputs, or validate measurements. In complex workflows, multiple strategically-placed Panels act like print statements in code—they reveal what's happening inside your parametric logic.",
  textNote: "A hybrid node that combines documentation with data pass-through. Unlike plain Text (which has no ports), Text Note accepts input data, displays it alongside your custom annotation, and passes the data unchanged to downstream nodes. This makes it perfect for inline commentary: 'This is the optimized volume fraction' or 'Vertices after decimation.' The note content is editable text that lives with the data it describes. Use Text Note when you want to annotate intermediate values without breaking the data flow. It's like adding a comment to a variable in code—the comment travels with the value, making the workflow self-explanatory.",
  slider: "The cornerstone of interactive parametric design in Numerica. A slider outputs a single numeric value that you control by dragging a handle or clicking along a track. The Min and Max parameters define the value range, while Step controls the increment precision (set to 1 for integers, 0.1 for one decimal place, etc.). Sliders are the primary way to introduce human agency into computational workflows—they're the knobs and dials of your parametric instrument. Connect sliders to node parameters to enable real-time design exploration: adjust a facade depth, tune a structural member thickness, control an array count. Name your sliders descriptively ('Beam Width', 'Floor Height') and set ranges that represent realistic design possibilities.",
  colorPicker: "A visual color selection interface that outputs color data in two formats: an RGB vector {x,y,z} with components ranging 0-1, and a hexadecimal string for web/CSS compatibility. Click the swatch to open the color picker dialog. The dual output format ensures flexibility—use the vector output for Custom Material nodes and geometry coloring, use the hex output for UI integration or data export. Color Picker brings visual design decisions into the parametric workflow. Combined with arrays or conditionals, you can create color schemes that respond to geometry properties, orientation, or performance metrics.",
  customMaterial: "Applies a visualization color to geometry without modifying the geometry data itself. This is a render-only effect—the colored geometry displays in Roslyn with your chosen color, but the underlying vertex data, topology, and coordinates remain unchanged. Connect a geometry input and a color (from Color Picker or a constructed RGB vector). The output geometry carries color metadata that Roslyn's renderer interprets. Use Custom Material to visually distinguish different parts of your workflow, to preview material assignments before export, or to create presentation-ready visualizations. Multiple Custom Materials with different colors can highlight different zones or performance levels.",

  // === PREVIEW & VIEWER NODES ===
  geometryViewer: "An embedded 3D viewport that displays geometry directly within the Numerica canvas. This mini-viewer supports full navigation: rotate by dragging, pan with shift-drag, zoom with scroll. Geometry Viewer provides immediate visual feedback without switching to Roslyn, making it invaluable for iterative workflows. Connect any geometry output to see its current form update live as upstream parameters change. The optional Filter input accepts Preview Filter nodes to customize display mode (wireframe, ghosted, shaded). The type output reports the geometry kind for conditional logic. Place Geometry Viewers at workflow milestones—after major transformations, solver outputs, or final results—to maintain visual awareness of what your graph is producing.",
  customViewer: "A lightweight viewer node that exposes connected geometry for review in Roslyn. Connect any geometry output and use it as the designated preview for what should appear in the Roslyn viewport and downstream exports. Custom Viewer keeps geometry data unchanged—it simply provides a clean anchor point for visualization and selection workflows.",
  customPreview: "Combines geometry with display filter settings for styled visualization. Unlike Geometry Viewer (which has its own viewport), Custom Preview affects how geometry appears in the main Roslyn viewport when you sync the workflow. Connect geometry and a Preview Filter node to control shading mode, transparency, edge display, and culling. The geometry passes through unchanged—Custom Preview only attaches rendering metadata. Use Custom Preview to create side-by-side comparisons of different visualization styles, or to prepare geometry for specific presentation needs without modifying the underlying data.",
  previewFilter: "Generates display configuration settings for Custom Preview and Geometry Viewer nodes. Parameters include display mode (shaded, wireframe, ghosted, silhouette), solidity (opacity level), sheen (surface reflectivity), and culling (front/back face visibility). Preview Filter doesn't display anything itself—it outputs filter settings that other nodes consume. Create multiple Preview Filter nodes with different configurations to enable quick comparisons. For example, one filter set to wireframe reveals topology, while another set to ghosted shows internal structure. This separation of display settings from geometry keeps your workflow modular.",
  metadataPanel: "A specialized inspection node that extracts and displays comprehensive geometry metadata. Unlike Panel (which shows raw values), Metadata Panel presents structured information: vertex count, face count, edge count, bounding box dimensions, center point, surface area, and volume (for closed meshes). This data is essential for validation ('Is the mesh closed?'), documentation ('What's the floor area?'), and conditional logic ('If volume > threshold, use different approach'). Metadata Panel outputs individual values that can drive downstream calculations—connect the volume output to a cost calculation, or use vertex count to choose a decimation strategy.",
  annotations: "Creates floating 3D text labels anchored to positions in the Roslyn viewport. Specify the anchor point (a position vector or reference to geometry), the text content, and the size. Annotations appear as screen-facing labels that scale appropriately with zoom. Use annotations for dimensioning ('3.2m'), feature labeling ('Primary Support'), or construction notes ('Check clearance here'). Unlike Text nodes (which live on the Numerica canvas), annotations exist in 3D space and move with their anchor points. They're essential for creating presentation-ready viewports and communicating design intent.",
  dimensions: "Automatically displays the bounding box dimensions of connected geometry as an overlay in Roslyn. Width, depth, and height measurements appear as editable, live values that update when geometry changes. Dimensions are fundamental for design verification—confirming that parametric adjustments produce the intended sizes. The overlay graphics integrate with Roslyn's display system, positioning dimension lines appropriately. Use Dimensions throughout iterative design to maintain awareness of scale, especially when working with proportional relationships or space constraints.",

  // === MESH CONVERSION NODES ===
  meshConvert: "The universal translator between Lingua's geometry paradigms. Mesh Convert intelligently handles any input type: NURBS curves become tubular pipe meshes (with Thickness controlling diameter), NURBS surfaces are tessellated into triangle meshes preserving curvature, B-Rep solids are decomposed into watertight triangle meshes, and point/vertex geometry becomes small spheres at each location. This node embodies the philosophy that different geometry types serve different purposes—precise NURBS for design, faceted meshes for fabrication and display. The Direction parameter overrides the default extrusion vector when creating pipes from curves. Place Mesh Convert at the boundary between NURBS-based design and mesh-based operations like Boolean, export, or subdivision.",
  nurbsToMesh: "Converts mathematically-exact NURBS curves and surfaces into discrete triangle meshes suitable for rendering, export, and mesh-based operations. For curves, the result is a tubular pipe mesh with circular cross-section—the Thickness parameter sets the pipe diameter, and Capped controls whether the ends are closed. For surfaces, the node tessellates the continuous surface into a triangle approximation, balancing accuracy against mesh density. This conversion is often necessary because many downstream operations (Booleans, STL export, subdivision) require mesh input. The conversion is lossy—you cannot perfectly recover the original NURBS from the mesh—so preserve your NURBS sources when precision matters.",
  brepToMesh: "Tessellates B-Rep (Boundary Representation) solid geometry into triangle mesh format. B-Rep represents solids as collections of trimmed surface patches with topological connectivity—the gold standard for CAD precision. Tessellation samples these surfaces to create a mesh approximation suitable for visualization, export, and mesh-based editing. The tessellation quality parameters control the trade-off between accuracy (more triangles, closer to true surface) and performance (fewer triangles, faster operations). Face boundaries are preserved where possible, maintaining the semantic distinction between different surfaces of the solid. Required before mesh operations or STL export.",
  meshToBrep: "Elevates mesh geometry into the B-Rep (Boundary Representation) paradigm, enabling topology-aware operations like precise Booleans and CAD-style editing. Each mesh triangle becomes a planar B-Rep face with exact geometric definition. This is particularly useful for imported STL files or scanned geometry that needs to participate in solid modeling operations. Important limitation: the result is 'triangle soup'—the B-Rep accurately represents the mesh triangles but doesn't recover smooth surfaces or design intent. For imported geometry, consider this a way to unlock B-Rep operations, not a path to perfect CAD reconstruction.",

  // === MESH EDITING NODES ===
  mesh: "A simple pass-through node for mesh geometry. Use this node to organize your workflow, create clean connection points, or prepare geometry for ontologization (baking to Roslyn). The mesh node accepts geometry input and outputs it unchanged, making it perfect for workflow organization and as an anchor point for right-click operations like 'Ontologize to Roslyn' which bakes the connected geometry into the scene. Think of it as a named waypoint in your data flow—it doesn't transform the geometry, but it makes the workflow more readable and provides a clean interface for downstream operations.",
  subdivideMesh: "Increases mesh resolution by splitting faces according to a subdivision scheme, optionally smoothing the surface in the process. This is fundamental for creating smooth organic forms from coarse base meshes. Linear subdivision simply splits each face into smaller faces without changing the overall shape—useful for adding detail while preserving faceted forms. Catmull-Clark subdivision (designed for quad meshes) rounds corners and smooths surfaces toward a limit surface, creating the organic smoothness seen in character modeling. Loop subdivision applies similar smoothing principles to triangle meshes. Adaptive subdivision varies the subdivision level based on local curvature, adding detail where needed. The Iterations parameter controls recursive subdivision depth—each iteration roughly quadruples face count, so use restraint (2-3 iterations is usually sufficient).",
  dualMesh: "Transforms a mesh into its topological dual—a profound geometric operation that swaps the roles of faces and vertices. In the dual, each original face becomes a vertex (positioned at the face center), and each original vertex becomes a face (connecting all the original faces that shared that vertex). For triangular meshes, this creates hexagonal patterns; for hexagonal meshes, it creates triangular patterns. Duality is its own inverse: applying it twice returns to a mesh topologically equivalent to the original. Use Dual Mesh to create Voronoi-like cellular patterns from point distributions, to convert between triangular and hexagonal lattices, or to explore the deep mathematical symmetry between mesh elements.",
  insetFaces: "Shrinks the selected faces of a mesh inward, creating a ring of new faces around each original face's perimeter. The Inset Amount controls how far the face shrinks—larger values create wider borders. This operation is foundational for architectural panel patterns: inset a facade grid to create window frames, inset floor tiles to create grout lines, inset structural bays to articulate depth. Inset preserves face normals and creates quad strips around the perimeter. Often used as preparation for Extrude Faces—inset first to define the zone, then extrude to add depth. The combination of Inset + Extrude is the mesh modeling equivalent of adding a profiled frame.",
  extrudeFaces: "The defining operation of mesh modeling: pulling (or pushing) selected faces along their normal directions to create depth. Positive distance extrudes outward from the mesh, negative distance extrudes inward (carving). New side faces are automatically created connecting the moved faces to their original positions. The Cap parameter controls whether the extruded end is closed (creating a solid protrusion) or open (creating a tube). Extrude Faces transforms flat surfaces into 3D volumes, flat patterns into relief textures, and simple forms into complex architectural details. Combined with face selection, you can extrude specific zones while leaving others flat—essential for creating varied facades, articulated structures, or topographical variations.",
  meshRelax: "Smooths a mesh by iteratively averaging each vertex position with its neighbors, creating an organic softening effect. Unlike subdivision (which adds geometry), relaxation moves existing vertices toward local equilibrium without changing face count. Iterations control smoothing intensity—more iterations produce smoother results but may shrink features. The Keep Boundary option anchors edge vertices in place, preventing the mesh from contracting. Use Mesh Relax to soften hard edges, blend mesh modifications, reduce noise from scanned geometry, or create organic transitions. Relaxation tends toward minimal surfaces (like soap films), making it useful for finding forms that balance tension—though for true structural optimization, use the Physics Solver.",
  selectFaces: "Filters mesh faces based on their normal direction relative to a reference vector, returning a submesh containing only the matching faces. The direction parameter sets the target normal (e.g., straight up for horizontal faces), and the angle threshold defines how closely faces must align to be included. This is essential for targeted operations: select upward-facing faces to place solar panels, select vertical faces for facade treatment, select angled faces for drainage analysis. The output is a valid submesh that can be independently processed—extrude selected faces, assign different materials, apply different subdivision levels. Combine with Boolean or mesh merging to reassemble the processed parts.",
  meshBoolean: "Performs constructive solid geometry (CSG) Boolean operations on mesh geometry: Union combines two meshes into one (additive), Difference subtracts the second mesh from the first (carving), and Intersection keeps only the overlapping volume (masking). Both input meshes must be closed and watertight—open surfaces or non-manifold edges cause failures. Booleans are the fundamental operations for constructive modeling: union structural members, subtract openings and penetrations, intersect to find common volumes. The output is a single watertight mesh. For complex designs, chain multiple Boolean operations, but be aware that each operation may introduce numerical artifacts at intersection edges—Mesh Repair can help clean these up.",
  triangulateMesh: "Converts all mesh faces to triangles by splitting quads and n-gons. Many mesh operations and export formats require strictly triangular meshes. Triangulation preserves the mesh surface exactly—no smoothing or displacement occurs—while ensuring that every face has exactly three vertices. Quads are typically split along the shorter diagonal to preserve shape quality. N-gons (faces with more than 4 vertices) are fan-triangulated from a central vertex. Apply Triangulate Mesh before STL export, before sending to renderers that require triangles, or before operations that assume triangular input. For the reverse operation (creating quads from triangles), use Quad Remesh.",
  meshRepair: "Automatically detects and fixes common mesh defects that prevent proper display, export, or downstream operations. Repairs include: removing degenerate faces (zero-area triangles), removing duplicate vertices (vertices at identical positions), filling small holes (gaps in the mesh surface), fixing inconsistent normal orientation (inside-out faces), and removing non-manifold edges (edges shared by more than two faces). Run Mesh Repair after importing external geometry, after complex Boolean operations, or when downstream nodes report mesh errors. The repair process makes best-effort fixes—for severely damaged meshes, manual repair in dedicated mesh software may be necessary.",
  meshUVs: "Generates UV texture coordinates that map 2D images onto 3D mesh surfaces. UV coordinates are essential for texture mapping, material assignment, and any operation that requires unwrapping a 3D surface to 2D. Methods include: Planar (projects along a single direction, good for flat surfaces), Box (six-direction projection, good for boxy shapes), Cylindrical (wraps around an axis, good for bottles and columns), and Spherical (radial projection, good for balls and domes). Scale and Offset parameters adjust the mapping density and position. Proper UVs ensure textures align correctly and tile without distortion—critical for architectural visualization, game assets, and fabrication patterns.",
  meshDecimate: "Reduces mesh complexity by removing vertices and faces while preserving overall shape. Target the desired face count or reduction ratio (0.5 = half the faces). Decimation uses edge collapse and vertex clustering to simplify geometry while respecting feature preservation parameters—sharp edges and boundaries can be protected from aggressive simplification. Use Mesh Decimate to optimize heavy meshes for performance (faster rendering, smaller file sizes), to prepare scan data for modeling, or to create level-of-detail variants. Severe decimation will eventually degrade quality, so find the balance between polygon count and acceptable fidelity for your use case.",
  quadRemesh: "Converts an arbitrary triangle mesh to a quad-dominant mesh with clean, flowing edge loops. Quads are preferred for subdivision (Catmull-Clark works best on quads), for animation (deformation follows edge flow), and for manual editing (easier to select loops and modify). The target face count parameter controls resulting density. Quad Remesh analyzes the surface curvature to place quad edges along principal directions, creating natural-looking topology even from messy triangle input. This is not a trivial operation—quad remeshing is an active research area—so results may vary depending on surface complexity. Use for converting scan data, cleaning up Boolean results, or preparing meshes for subdivision modeling.",

  // === TESSELLATION & PATTERNS ===
  geodesicSphere: "Creates sphere meshes using geodesic subdivision of an icosahedron, resulting in nearly-equal triangles evenly distributed across the surface. Unlike latitude-longitude spheres (which concentrate vertices at poles), geodesic spheres have consistent face sizes throughout—ideal for structural applications like geodesic domes, sphere-based deformations, and computational geometry. The Frequency parameter controls subdivision level: frequency 1 gives the base icosahedron (20 faces), higher frequencies create denser approximations to a perfect sphere. Geodesic spheres have elegant mathematical properties: they minimize edge length variation, they're structurally efficient, and they discretize spherical geometry fairly. Buckminster Fuller popularized geodesic structures; this node generates them computationally.",
  voronoiPattern: "Generates 3D Voronoi diagrams from point distributions—the fundamental pattern of natural cellular division. Given a set of seed points, the Voronoi diagram partitions space so that each cell contains all points closer to its seed than to any other seed. Cell boundaries form where distances to neighboring seeds are equal. This creates organic-looking cellular patterns reminiscent of foam bubbles, cracked mud, giraffe spots, or insect wings. Feed point clouds (from random distributions, surface samples, or attractors) to generate patterns that respond to density variation. Voronoi patterns have deep connections to optimal material distribution, minimal surfaces, and natural growth—making them architecturally and structurally meaningful, not just decorative.",
  hexagonalTiling: "Creates regular hexagonal tessellation patterns on surfaces. Hexagons tile the plane with maximum area-to-perimeter ratio (after the circle), making them efficient for material usage. They're structurally excellent: honeycomb is the optimal 2D structure for strength-to-weight. The Size parameter controls hexagon radius, Count controls the extent of the pattern. Hexagonal Tiling is fundamental for floor patterns, facade panelization, structural lattices, and any application where you want dense, efficient packing. The regular hexagonal grid is also the dual of the triangular grid (see Dual Mesh), connecting these pattern types through topological transformation.",
  offsetPattern: "Transforms solid pattern faces into framed outlines by offsetting edges inward, creating gaps between adjacent elements. Frame Width controls the offset distance—larger values create thinner pattern elements with wider gaps. This operation is essential for converting panelization designs into manufacturable lattices: offset a facade grid to create framed window modules, offset floor tiles to create grout lines, offset structural bays to create perimeter beams. The resulting geometry separates into distinct elements suitable for individual fabrication or analysis. Offset Pattern works on any mesh, turning connected faces into separated frames.",

  // === IMPORT/EXPORT NODES ===
  stlImport: "Imports STL (STereoLithography) mesh files into the Numerica workflow. STL is the universal exchange format for triangle meshes, used by 3D printers, CNC machines, and most 3D software. Both ASCII and binary STL formats are supported—binary is more compact. Imported meshes are standard Lingua mesh geometry, ready for any mesh operation: Boolean, subdivision, decimation, analysis. Use STL Import to bring in 3D scans, downloaded models, CAD exports, or any external triangle mesh data. Note that STL carries only geometry—no color, texture, or material information is preserved. For meshes with metadata, use other import formats when available.",
  stlExport: "Exports mesh geometry to STL file format, the universal standard for 3D printing and CNC fabrication. Choose between ASCII format (human-readable, larger files) and Binary format (compact, faster to process). The output is a file path string that can be connected to download or file system operations. Before export, ensure your mesh is triangulated and closed (watertight) for best compatibility with 3D printers. STL Export is the final step in many fabrication workflows: design parametrically → optimize → decimate → export → print. The simplicity of STL (just triangles, no materials or metadata) makes it universally supported but limited for complex interchange.",

  // === PRIMITIVE GEOMETRY NODES ===
  point: "The atomic element of geometry: a single location in 3D space defined by XYZ coordinates. Points have position but no extent, volume, or direction—they are pure location. In Numerica, points serve as construction references (place nodes at key positions), as attractor centers for field-based modeling, as control vertices for curves, or as samples for analysis. Connect Point outputs to Point Cloud to build collections, or use them in distance calculations, proximity queries, and spatial analysis. Points are the foundation upon which more complex geometry is built—curves pass through points, surfaces span between points, and meshes triangulate points.",
  pointCloud: "Assembles multiple points into a unified collection, representing a discrete sampling of space. Input can be a list of position vectors, or separate lists of X, Y, and Z coordinates that are combined element-wise. Point clouds are fundamental for: representing scan data, defining attractor fields, sampling surfaces for analysis, seeding random distributions, and providing input for Voronoi patterns or Delaunay triangulation. Unlike individual Point nodes (which create one point each), Point Cloud efficiently handles thousands of points, making it suitable for data-intensive operations. The cloud is ordered—point indices correspond to list positions.",
  line: "Creates a linear segment connecting two points in space—the simplest curve possible. A line has start point, end point, direction, and length, all of which are available as outputs for downstream calculations. Lines serve as construction geometry (axis references, measurement baselines), as sweep paths for simple extrusions, as structural members in wireframe models, or as input for array spacing calculations. Unlike polylines (which can have many vertices), a Line is specifically a single segment between exactly two points. Connect start and end points from other geometry to create dynamic lines that update as positions change.",
  rectangle: "Creates a four-sided closed polyline with right-angle corners, oriented on a specified plane. Width and Height parameters define the dimensions, Center positions the rectangle in space, and Plane orients it (defaulting to the XY plane). The output is a closed curve suitable for extrusion into boxes, for boundary definition, or as a profile for sweep operations. Rectangles are the foundation of orthogonal design: floor plates, window openings, panel outlines, grid cells. For rotated rectangles, adjust the Plane parameter rather than applying a post-transform. The 4-vertex polyline output can be fed to any curve operation.",
  circle: "Creates a perfect circular curve with mathematically exact curvature, represented as a NURBS curve. Specify Center (the focal point), Radius (the distance from center to perimeter), and Plane (the orientation surface). Circles are closed curves with constant curvature throughout—they're the NURBS equivalent of mathematical perfection. Use circles as extrusion profiles (for cylinders), as trim boundaries, as construction references, or as the basis for arc extraction. The NURBS representation means circles can participate in surface operations (revolve, loft) and maintain precision through transformations.",
  arc: "Creates a portion of a circle—a curved segment between two angular positions. Specify Center, Radius, Start Angle, and End Angle (in degrees) to define the arc extent. The output is an open NURBS curve with mathematically exact circular curvature along its length. Arcs are essential for: rounded corners (what filleted polylines become), curved transitions between straight segments, cam profiles, arch geometries, and any design requiring precise circular segments. Unlike freeform curves (which approximate curvature), arcs have constant radius throughout—their curvature is geometrically pure.",
  curve: "Creates a NURBS (Non-Uniform Rational B-Spline) curve influenced by a series of control points. Unlike polylines (which pass through their vertices), NURBS curves are pulled toward their control points without necessarily touching them—the curve flows smoothly near the control polygon. The Degree parameter controls curve flexibility: degree 1 is a polyline, degree 2 (quadratic) allows simple curves, degree 3 (cubic) is the most common for smooth design curves, higher degrees increase mathematical complexity. NURBS curves are the professional standard for freeform design: they're smooth, they have exact mathematical representation, and they can be precisely evaluated at any parameter. Use for sweep paths, profile curves, architectural features, or any organic linear element.",
  polyline: "Connects a sequence of points with straight line segments, creating a multi-vertex linear path. Points are connected in order, and the Closed parameter determines whether the last point connects back to the first (creating a polygon) or leaves the ends open. Polylines are the workhorse of architectural drawing: floor plan outlines, section cuts, profile definitions, fence lines. They're simpler than NURBS curves but sufficient for rectilinear design. Polylines can be smoothed (via Interpolate), offset, extruded, or used as boundary definitions. The sequential vertex list provides natural ordering for array operations or progressive transformations.",
  surface: "Creates a surface from boundary curves—the fundamental operation for spanning 2D profile curves into 3D surface geometry. For a single closed curve input, Surface creates a planar fill (like stretching fabric across a frame). For multiple curves, it attempts to loft or patch between them to create a spanning surface. The output is NURBS surface geometry with exact mathematical definition, suitable for further surface operations (trim, offset, boolean) or conversion to mesh. Surface creation is where curves become form—floor plates from outlines, walls from sections, roofs from profiles.",
  loft: "Creates a surface by connecting a sequence of profile curves, like draping fabric between ribs. Curves are connected in order, so consistent curve direction and logical sequencing matter—reversed or out-of-order profiles create twisted, self-intersecting surfaces. Lofting is fundamental for complex architectural forms: smooth transitions between floor plates of different shapes, hull forms, blade profiles, organic enclosures. The resulting NURBS surface interpolates between the profiles, creating smooth transitions where the profiles differ. Options control tangent continuity at profiles—for smoother results at endpoints.",
  extrude: "The fundamental 2D-to-3D operation: pushes a curve or surface along a direction vector to create solid or surface geometry. For curves, extrusion creates surfaces; for surfaces, extrusion creates solids. The Distance parameter sets how far to extrude, and the Direction vector (defaulting to surface normal or Z-axis) controls the extrusion path. The Cap option determines whether the extruded ends are closed (creating a solid) or open (creating a shell). Extrusion is the bread and butter of CAD: floor outlines become walls, profiles become beams, sections become solids. Combined with Boolean operations, extrusion enables constructive solid modeling.",
  pipeSweep: "Creates tubular mesh geometry by sweeping a circular profile along a curve path—think of it as drawing with a round brush tip. Radius controls the tube diameter, Segments controls the smoothness of the circular cross-section (more segments = rounder, but heavier mesh). Pipe Sweep is essential for: railings, cables, structural tubes, plumbing, handrails, furniture frames—anything that's 'rod-like.' The mesh output follows the curve path, handling bends and turns automatically. For joining multiple pipe segments at branches, use Pipe Merge afterward. The circular cross-section is constant—for variable-width pipes, consider Loft with circle profiles instead.",
  pipeMerge: "Intelligently combines multiple pipe segments at junction points, creating smooth blend geometry where pipes meet. Branching tubular networks (piping systems, tree branches, structural nodes) naturally have complex intersections—Pipe Merge generates the transition geometry that connects individual pipes into a unified mesh. Feed pipe geometries from multiple Pipe Sweep nodes, and Pipe Merge analyzes their endpoints to detect junctions and generate appropriate blending. The result is a single watertight mesh suitable for fabrication or rendering. Without Pipe Merge, pipe junctions would have gaps or overlaps; with it, you get professionally joined tube networks.",

  // === BOOLEAN & MODIFIERS ===
  boolean: "Performs constructive solid geometry (CSG) operations on solid geometry, enabling additive and subtractive modeling. Three operations are available: Union combines two solids into one (additive manufacturing, assemblies), Difference subtracts the second solid from the first (carving openings, creating pockets), and Intersection keeps only the volume where both solids overlap (finding common space, creating masks). Both inputs must be closed, watertight solids—open surfaces or non-manifold geometry will cause failures. Boolean operations are the foundation of constructive modeling: every complex form can be built from primitive combinations. Chain multiple Booleans for complex results, and use Mesh Repair to clean up any artifacts at intersection edges.",
  offset: "Displaces curves perpendicular to their direction by a specified distance, creating parallel copies at a consistent offset. Positive values offset in the normal direction (typically outward for closed curves), negative values offset inward. The operation handles self-intersections that occur when offsets exceed the curve's minimum radius. Offset is fundamental for: creating wall thickness from centerlines, generating concentric patterns, defining margins and clearances, creating stepped profiles. For surfaces, use Offset Surface instead. The offset direction depends on curve orientation—reverse the curve if offset goes the wrong way.",
  fillet: "Replaces sharp corners in polylines with smooth circular arcs, creating rounded transitions between straight segments. The Radius parameter controls the arc size—larger radii create gentler curves, smaller radii create tighter corners. Fillet rebuilds the polyline, replacing vertex corners with arc geometry. This is essential for: mechanical profiles that need smooth transitions, ergonomic edges, manufacturing constraints that prohibit sharp corners, and aesthetic softening. Fillet operates on polylines (linear segments); for mesh edges, use Fillet Edges. The fillet radius is limited by the angle and length of adjacent segments—very tight corners may not accommodate large radii.",
  filletEdges: "Bevels or rounds selected edges of a mesh, replacing sharp edge intersections with new faces that create chamfered or smoothly curved transitions. Width controls how far the bevel extends from the original edge, Segments controls smoothness (1 = chamfer, more = rounder). Fillet Edges is the mesh equivalent of breaking a sharp edge: it softens hard intersections for visual appeal, manufacturing feasibility, and realistic appearance. Apply to boxes for softer edges, to Boolean results to smooth intersection lines, or to any mesh where sharp edges are undesirable. Edge selection determines which edges are affected—unselected edges remain sharp.",
  offsetSurface: "Displaces a surface along its normal vectors by a consistent distance, creating a parallel copy of the original surface. This is the surface equivalent of curve offset—every point moves perpendicular to the local surface by the specified amount. Direction controls which side of the surface is offset (positive normal or negative). Use Offset Surface to: create wall thickness from single surfaces, generate clearance envelopes, define parallel shells for analysis, or prepare for solid creation by Thicken Mesh. Note that highly curved surfaces may self-intersect when offset inward past their minimum radius of curvature.",
  thickenMesh: "Transforms a surface mesh into a solid by offsetting along normals and stitching the boundaries, creating a shell with specified thickness. The input is a surface (open mesh), the output is a solid (closed mesh) with uniform wall thickness. Distance controls the shell thickness. This is essential for: preparing thin-shell structures for 3D printing (single surfaces can't be printed), creating hollow volumes from surfaces, or generating structural shells from form-finding results. The operation handles boundary stitching automatically, creating new faces that close the shell edges.",
  plasticwrap: "Conforms a mesh toward a target surface using raycasting projection, creating a shrink-wrap effect where the mesh drapes over the target. Blend controls projection intensity: 0 leaves the mesh unchanged, 1 fully projects it onto the target. Intermediate values create partial conformance. Plasticwrap is useful for: creating packaging that follows product shapes, draping fabric over forms, conforming scan data to design surfaces, or generating offset shells that follow complex topology. The raycasting approach means the mesh must 'see' the target surface—concavities and internal geometry may not project correctly.",
  solid: "Attempts to convert mesh geometry into a proper closed solid by capping boundary loops and ensuring consistent normal orientation. Solid meshes are required for Boolean operations, volume calculations, and 3D printing. If the input mesh is already closed, Solid verifies and fixes normal consistency. If the input has boundary edges (holes), Solid attempts to cap them with planar faces. This is a best-effort repair operation—meshes with complex topology or large holes may not produce valid solids. Use Mesh Repair for more comprehensive fixes, or Thicken Mesh for guaranteed solid output from surfaces.",
  primitive: "A convenience node that creates basic geometric primitives with a selectable type dropdown. Choose from box, sphere, cylinder, cone, torus, and other fundamental shapes—the parameter panel adapts to show relevant inputs for each type. Primitive is useful for quick experimentation, for creating placeholder geometry, or when you want to rapidly switch between shape types without rewiring nodes. The underlying geometry is identical to dedicated primitive nodes (Box, Sphere, etc.), but accessed through a unified interface. For production workflows, dedicated nodes are often clearer; Primitive excels for exploration and prototyping.",
  box: "Creates axis-aligned rectangular prism geometry—the fundamental building block of orthogonal design. Width, Depth, and Height parameters define the three dimensions independently. Center positions the box in space. The output is a mesh with 6 faces, 8 vertices, and 12 edges. Boxes are the starting point for countless operations: extrude profiles create boxes, Boolean subtraction from boxes creates carved forms, arrays of boxes create grids. In architecture, boxes represent rooms, volumes, bounding regions, or massing studies. The axis-aligned constraint keeps boxes orthogonal—for rotated boxes, apply a Transform afterward.",
  sphere: "Creates a spherical mesh centered at the origin with specified Radius. Segments controls the approximation quality—more segments create a rounder sphere (closer to mathematical perfection) but with more triangles. The mesh is a triangulated approximation because perfect spheres cannot be exactly represented as flat-faced meshes. Spheres are fundamental for: ball geometry, dome structures, spherical field boundaries, planet/celestial visualization, or as Boolean operators for creating rounded cavities. For geodesic spheres (more uniform triangle distribution), use Geodesic Sphere instead. The standard sphere has polar concentration of vertices.",

  // === VOXEL OPERATIONS ===
  voxelizeGeometry: "Converts continuous geometry into a discrete 3D voxel grid—the volumetric equivalent of rasterizing an image. Each voxel (volumetric pixel) represents a cubic cell that's either inside or outside the geometry, or contains a density value. Resolution controls the voxel size: higher resolution captures finer detail but creates exponentially more cells (doubling resolution octuples the voxel count). Surface mode creates a thin shell of voxels at the geometry boundary; Solid mode fills the entire interior. The output is a 3D scalar field suitable for topology optimization, volume analysis, or isosurface extraction. Voxelization is the gateway to voxel-based operations that would be impossible on surface representations.",
  extractIsosurface: "Reconstructs a mesh surface from a voxel density field at a specified threshold value (the 'iso value'). Using the Marching Cubes algorithm, it finds where the density field crosses the threshold and generates smooth triangular faces at those transition points. This is the inverse operation to voxelization—going from volumetric data back to surface mesh. Extract Isosurface is essential for visualizing topology optimization results (where density represents material presence), for converting medical scan data to printable geometry, or for generating terrain from procedural noise fields. The iso value controls what density level defines the surface boundary.",

  // === SOLVER NODES ===
  topologyOptimize: "Configures the parameter set for density-based topology optimization—the mathematical framework for finding optimal material distributions. Parameters include: Volume Fraction (how much material to retain, typically 0.2-0.5), Penalty Factor (SIMP penalization that pushes densities toward 0 or 1), Filter Radius (minimum feature size to prevent checkerboard patterns), and convergence criteria. Connect this configuration to the Topology Solver along with geometry and load/boundary goals. The optimizer iteratively redistributes material density to maximize stiffness while satisfying the volume constraint. Monitor convergence through the solver popup—watch compliance (strain energy) decrease as the optimizer finds load-efficient paths.",
  topologySolver: "The computational engine for density-based topology optimization—one of the most powerful tools in structural engineering. Given a design domain, loads, and supports, the solver iteratively evolves a material density distribution that maximizes structural stiffness while using only the allowed volume of material. The process reveals the fundamental load paths through a structure: where material is needed (high density) and where it's wasted (low density). Input the base geometry (the design domain where material can exist), connect Goal nodes defining loads and anchors, configure optimization parameters, and run. The output is a density field showing optimal material distribution—use Extract Isosurface to convert this to geometry. Topology optimization produces forms impossible to conceive through intuition, revealing efficient structures that mimic bone, tree roots, and natural load-bearing systems.",
  physicsSolver: "Performs structural analysis using finite element methods, calculating how structures respond to loads. The solver assembles a stiffness matrix from mesh geometry and material properties, applies boundary conditions (anchors) and loads, then solves the equilibrium equation Kd = F to find displacements. From displacements, it derives stress and strain fields throughout the structure. Connect mesh geometry to the baseMesh input, wire Goal nodes for loads (forces) and anchors (fixed supports), optionally add stiffness and volume goals for optimization. Outputs include the deformed mesh (showing structural deflection), stress field (where material is working hardest), displacement vectors, and diagnostic data. Physics Solver is the core tool for structural validation—checking that designs can carry their loads—and for form-finding where structure shapes itself optimally.",
  voxelSolver: "A streamlined interface to voxel-based topology optimization, packaging Voxelize Geometry, Topology Optimize, Topology Solver, and Extract Isosurface into a unified workflow. Input your design domain geometry, connect structural goals, set optimization parameters, and the solver handles voxelization, optimization iterations, and surface extraction automatically. This is topology optimization made accessible—the same powerful optimization mathematics as the individual nodes, but with cleaner parameter organization and automatic intermediate steps. Outputs include the optimized density field (for analysis) and the extracted mesh surface (for fabrication). Use Voxel Solver when you want structural optimization results without manually wiring the voxel processing pipeline.",
  chemistrySolver: "Implements multi-material optimization through particle-based simulation—a paradigm inspired by physical chemistry where different material species diffuse, react, and compete for space. Unlike single-material topology optimization (which decides where material exists), chemistry optimization decides which material belongs where. Define available materials with Chemistry Material Goal nodes, specify material seeds (starting regions), and add property goals (stiffness, mass, transparency, thermal). The solver simulates particles of different species diffusing through the domain, with energetic goals driving material concentrations toward optimal configurations. The result is functionally graded materials—smooth transitions from steel to ceramic to glass, optimized for structural performance, thermal behavior, or optical transmission. This enables designing multi-physics components impossible with discrete material assignments.",

  // === GOAL NODES (PHYSICS) ===
  stiffnessGoal: "Defines stiffness targets for structural optimization, encoding the desire for a rigid, deflection-resistant structure. Stiffness (measured by Young's modulus in physics) determines how much a material resists deformation under load. In optimization, the Stiffness Goal drives material toward regions where load paths require resistance. Weight (0-1) controls importance relative to other goals. Higher stiffness goals push the optimizer to create thick, direct load paths; lower goals permit more flexible, lightweight solutions. Connect to Physics Solver or Topology Solver. Combined with Volume Goal, Stiffness Goal enables classic compliance minimization—finding the stiffest possible structure using a limited material budget.",
  volumeGoal: "Constrains the total material volume in optimization problems, representing material budget or weight limitations. The Target Fraction (0-1) specifies what percentage of the design domain should contain material: 0.3 means keep only 30% of the possible volume. This constraint forces the optimizer to make efficient choices—every bit of material must earn its place by contributing to structural performance. Volume Goal is essential for lightweight design: without it, the optimizer would simply fill the entire domain with material (which is always stiffer but heavier and more expensive). The trade-off between volume and stiffness is the core tension of structural optimization.",
  loadGoal: "Defines external forces acting on a structure—the loads that the design must carry. Specify a force vector (direction and magnitude) and the application region (which geometry or vertices receive the load). Common loads include gravity (distributed downward force), wind (lateral pressure), point loads (concentrated forces), and live loads (occupancy). Multiple Load Goals can represent complex loading scenarios: dead load plus live load, or load combinations for code compliance. The solver calculates how these forces flow through the structure to the supports, revealing stress distributions and deflections. Load definition is the starting point of structural analysis—without knowing the forces, you cannot design the structure.",
  anchorGoal: "Establishes fixed boundary conditions—the supports where the structure connects to ground or to other structures. Anchored regions cannot move during analysis; they absorb the reaction forces that balance applied loads. Without anchors, a loaded structure would simply float away—there must be something to push back. Specify anchor points or geometry regions: a column base anchored to the floor, a beam end fixed to a wall, a bridge abutment connected to the riverbank. Anchors determine how forces flow: a cantilever has one anchor (base), a simply-supported beam has two (both ends), a continuous beam has many. The choice of anchoring dramatically affects structural behavior and optimization results.",

  // === GOAL NODES (CHEMISTRY/MATERIALS) ===
  chemistryStiffnessGoal: "Directs the Chemistry Solver to concentrate high-stiffness materials (metals, ceramics) in regions experiencing significant structural stress. The solver analyzes where loads flow and biases material composition toward species that can resist those loads. Weight (0-1) controls priority relative to other chemistry goals. A high Stiffness Goal creates steel cores where structure matters; a low goal permits lighter, softer materials throughout. Combined with Chemistry Mass Goal, you can optimize for stiff-but-light configurations—placing stiff materials only where structurally necessary. This is materials-aware structural optimization: not just where material goes, but what material.",
  chemistryMassGoal: "Drives the Chemistry Solver toward lightweight material configurations by penalizing high-density materials. Where structural demands permit, the solver will favor lighter species (aluminum over steel, foam over ceramic). Weight controls influence—high values prioritize lightweighting, low values permit denser solutions. Chemistry Mass Goal must be balanced against Stiffness Goal: aggressive mass reduction produces light but flexible structures, conservative mass goals produce heavy but rigid ones. The optimal balance depends on your design requirements—aerospace demands light, infrastructure demands robust. This goal enables density-conscious multi-material design.",
  chemistryBlendGoal: "Enforces smooth transitions between material species, preventing abrupt boundaries that cause stress concentrations and manufacturing difficulties. Smoothness (0-1) controls gradient sharpness: high values create gradual compositional changes across significant distances, low values permit sharper transitions. Blend Goal encodes the physics of functionally graded materials (FGMs)—the principle that continuous material gradients perform better than discrete layers. A steel-to-glass transition through intermediate ceramic is stronger than a direct steel-glass bond. This goal is essential for manufacturable, physically realistic multi-material designs.",
  chemistryMaterialGoal: "Assigns specific material species to geometry regions, seeding the Chemistry Solver with initial material locations. Connect geometry (the seed region) and select a material species from the library. The solver treats these assignments as starting conditions—material diffuses outward from seeds according to physical properties and optimization goals. Multiple Material Goals with different species create the compositional diversity that chemistry optimization exploits. Assign steel to structural cores, glass to facade zones, ceramic to transition regions—then let the solver optimize the precise boundaries and gradients between them.",
  chemistryTransparencyGoal: "Optimizes for optical transmission, biasing transparent materials (glass) toward regions requiring light passage. The solver identifies where transparency is valued—facades, skylights, light wells—and concentrates high-transmission species there. Weight controls priority: high values strongly prefer transparency even at structural cost, low values permit opacity where structurally beneficial. Combined with Stiffness Goal, you can create glazing systems that are both transparent and structurally capable—with optimal gradients from transparent surfaces to opaque structural cores.",
  chemistryThermalGoal: "Optimizes thermal conductivity distribution, placing materials according to heat transfer requirements. High-conductivity materials (metals) are positioned for heat paths—conducting heat where you want it to flow. Low-conductivity materials (ceramics, foams) are positioned for thermal barriers—blocking heat where you want insulation. The solver balances thermal performance against other goals (structural, optical). Use Chemistry Thermal Goal for heat sinks that conduct heat away from components, for insulated envelopes that minimize energy loss, or for thermal bridges that need careful conductivity management.",

  // === VECTOR OPERATIONS ===
  origin: "Outputs the world origin point (0, 0, 0) as a vector constant—the universal reference point where all coordinate axes intersect. In 3D space, the origin is the anchor from which all positions are measured. Use Origin as a reference point for symmetrical constructions, as the default position for objects that haven't been placed, or as one endpoint of measurements. This is a convenience constant that saves constructing a zero vector manually. In architectural contexts, the origin often represents a project reference point or building corner.",
  unitX: "Outputs the unit vector along the positive X-axis: (1, 0, 0). This is one of three standard basis vectors that define 3D coordinate space. Unit X represents the horizontal 'right' direction in standard orientation. Use for specifying X-axis movement, for calculating dot products that measure X-alignment, for defining extrusion directions along X, or as the reference direction for angular measurements. Unit vectors have magnitude 1, making them pure direction indicators without scale.",
  unitY: "Outputs the unit vector along the positive Y-axis: (0, 1, 0). In Lingua's coordinate convention, Y typically points 'forward' or into the screen in front views. Unit Y is essential for specifying directions along the Y-axis, for depth-related calculations, or as a reference for measuring deviation from the Y-axis. Combined with Unit X and Unit Z, these three vectors span all of 3D space—any direction can be expressed as a combination of these basis vectors.",
  unitZ: "Outputs the unit vector along the positive Z-axis: (0, 0, 1). In Lingua's coordinate system, Z is the vertical 'up' direction. Unit Z is fundamental for: gravity direction (negative Unit Z), extrusion directions for vertical elements, floor normal vectors, or any calculation requiring the world 'up' reference. When designing buildings, Z-up aligns with intuitive vertical thinking—floors are XY planes, walls extrude along Z.",
  unitXYZ: "Outputs the diagonal unit vector (1/√3, 1/√3, 1/√3)—a direction pointing equally toward all three positive axis directions, normalized to unit length. This vector represents the 'corner' direction of a cube, the space diagonal. Use for uniform scaling operations (scaling equally in all directions), for diagonal movements, or as a reference for isotropic properties. The normalization ensures consistent magnitude when used in calculations.",
  moveVector: "Constructs a translation vector from individual X, Y, Z displacement components. This is a convenience node that combines three separate number inputs into a single vector output suitable for Move or Transform operations. Instead of manually constructing vectors with Vector Construct, Move Vector provides a semantically clear interface: 'move by X in X, Y in Y, Z in Z.' Connect sliders to the inputs for interactive translation control. The output is equivalent to Vector Construct but named for its primary purpose.",
  scaleVector: "Constructs a scale factor vector from individual X, Y, Z components, designed for non-uniform scaling operations. Each component controls scale along its respective axis: 2 means double, 0.5 means half. Connect to Scale node's factor input for independent axis scaling. A scale vector of (1, 1, 2) doubles height while preserving width and depth. This enables anisotropic transformations—stretching or compressing differently in each direction—essential for fitting geometry to constraints.",
  vectorConstruct: "Assembles a vector from three separate number inputs representing X, Y, and Z components. This is the fundamental operation for creating vectors from computed or controlled values. Connect slider outputs to build interactive position controls, connect math outputs to build calculated directions, or connect list items to build vectors from data. Vector Construct is the inverse of Vector Deconstruct—together they enable full bidirectional conversion between vector and scalar representations.",
  vectorDeconstruct: "Disassembles a vector into three separate number outputs for X, Y, and Z components. This is essential when you need to work with individual coordinates: extracting the height (Z) of a point, comparing X positions, or feeding components into separate calculations. Vector Deconstruct paired with Vector Construct enables vector manipulation through scalar math: deconstruct, process each component, reconstruct. This pattern underlies complex vector transformations.",
  vectorAdd: "Performs component-wise addition of two vectors: result = (A.x + B.x, A.y + B.y, A.z + B.z). Vector addition has intuitive geometric meaning: placing vectors tip-to-tail, the sum goes from the first tail to the second tip. Use for: combining translations (move by A then by B), accumulating velocities or forces, blending positions (A + 0.5*(B-A) = midpoint), or offsetting points by displacement vectors. Addition is commutative: A + B = B + A.",
  vectorSubtract: "Performs component-wise subtraction: result = (A.x - B.x, A.y - B.y, A.z - B.z). The result is a vector pointing from B toward A, with length equal to the distance between them. Vector subtraction is fundamental for: calculating direction vectors between points, finding displacement (how to get from B to A), computing relative positions, or determining motion trajectories. Unlike addition, subtraction is not commutative: A - B ≠ B - A (they're opposite directions).",
  vectorScale: "Multiplies a vector by a scalar value, scaling its magnitude without changing its direction (unless the scalar is negative, which reverses direction). Result = (V.x * s, V.y * s, V.z * s). Scaling by 2 doubles length, by 0.5 halves it, by -1 reverses direction, by 0 produces the zero vector. Use for: adjusting force magnitudes, controlling movement speed, normalizing then scaling to desired length, or applying uniform transformations. This is different from component-wise multiplication of two vectors.",
  vectorLength: "Calculates the Euclidean magnitude (length) of a vector using the Pythagorean theorem: √(x² + y² + z²). The result is a non-negative scalar representing 'how long' the vector is, independent of direction. Length is fundamental for: measuring distances (length of difference vector), checking if vectors are normalized (length ≈ 1), thresholding by magnitude, or computing unit vectors (V / length(V)). For position vectors, length gives distance from origin.",
  vectorNormalize: "Scales a vector to unit length (magnitude = 1) while preserving its direction: result = V / |V|. Normalized vectors are pure direction indicators, stripped of magnitude information. Normalization is essential for: consistent speed movement (move by normalized direction * speed), direction comparisons (dot product of unit vectors ranges -1 to 1), shader calculations requiring unit normals, or anywhere direction matters but magnitude shouldn't. Normalizing a zero vector is undefined—the result is zero.",
  vectorDot: "Computes the dot product (inner product) of two vectors: A·B = A.x*B.x + A.y*B.y + A.z*B.z. The result is a scalar with deep geometric meaning: for unit vectors, it equals the cosine of the angle between them. Dot product = 1 means parallel (same direction), -1 means anti-parallel (opposite), 0 means perpendicular. Use for: calculating angles between directions, determining facing (is surface toward light?), projecting vectors, measuring alignment, or computing work (force · displacement).",
  vectorCross: "Computes the cross product of two vectors, yielding a third vector perpendicular to both inputs. The cross product only exists in 3D and produces a vector whose direction follows the right-hand rule, with magnitude equal to the parallelogram area spanned by the inputs. Cross product is essential for: computing surface normals (edge1 × edge2), finding rotation axes, calculating torque, determining perpendicular directions, or testing parallelism (parallel vectors have zero cross product). Unlike dot product, cross product is not commutative: A × B = -(B × A).",
  distance: "Calculates the Euclidean distance between two points (position vectors)—equivalent to the length of their difference vector. Distance = |A - B| = √((A.x-B.x)² + (A.y-B.y)² + (A.z-B.z)²). This is the straight-line spatial separation between positions, fundamental for: proximity detection (is something close?), spacing calculations (place objects apart by distance D), clustering analysis, or triggering distance-based behaviors. Distance is always non-negative and symmetric: dist(A,B) = dist(B,A).",
  vectorFromPoints: "Creates a direction vector pointing from the start point to the end point: result = End - Start. This is vector subtraction packaged with clear semantic meaning: 'the vector that would move you from Start to End.' The output has length equal to the distance between the points—normalize it if you need pure direction. Use for: aiming calculations, trajectory directions, orientation toward targets, or creating edges (a line from A to B is defined by this vector).",
  vectorAngle: "Calculates the angle between two vectors in degrees, ranging from 0° (parallel) to 180° (anti-parallel). This uses the dot product relationship: angle = arccos(A·B / (|A|*|B|)). Use for: measuring opening angles, detecting perpendicularity (90°), calculating bend angles in curves, validating orientations, or any geometric analysis requiring angular measurement. The result is always positive—the angle doesn't indicate which vector is 'ahead' of the other.",
  vectorLerp: "Performs linear interpolation between two vectors based on a factor t: result = A + t*(B - A) = A*(1-t) + B*t. When t=0, result is A; when t=1, result is B; when t=0.5, result is the midpoint. Values outside 0-1 extrapolate beyond the endpoints. Lerp is fundamental for: smooth transitions, parametric curves (points along a line), blending positions, animation interpolation, or creating evenly-spaced samples between two points. Lerp generalizes to multi-dimensional interpolation across all vector components.",
  vectorProject: "Projects vector A onto vector B, returning the component of A that lies in B's direction. The projection has the same direction as B (or opposite if A points somewhat backward) and magnitude equal to |A| * cos(angle). Projection decomposes a vector into parallel and perpendicular components relative to a reference direction. Use for: finding shadow lengths (project velocity onto ground), decomposing forces (parallel vs perpendicular to surface), constraining movement to axes, or calculating work components.",
  pointAttractor: "Creates a spatial influence field centered at a point, with strength that varies with distance. Geometry within the field can be attracted toward (positive strength) or repelled from (negative strength) the attractor point. Falloff controls how quickly influence decays with distance: sharp falloff concentrates effect near the point, gradual falloff spreads it wider. Use for: organic deformations (pulling surfaces toward points), particle system behaviors, field-based modeling techniques, or creating spatial gradients that drive procedural effects.",

  // === MATH OPERATIONS ===
  number: "Outputs a constant numeric value defined in the node's parameters—the simplest data source in Numerica. Use Number for: fixed parameters that shouldn't be interactively changed (π, gravity constant), magic numbers you want to name and locate (tolerance = 0.001), or default values that other nodes might override. Number is less flexible than Slider but clearer when values are truly constant. Named Number nodes document what values mean, improving workflow readability.",
  add: "Computes the sum of two numbers: result = A + B. Addition is the fundamental combining operation: accumulating values, applying offsets, combining measurements, building totals. In parametric design, Add enables: position offsets (base + adjustment), dimension totals (width + margin), accumulated transformations, or building complex expressions from simple parts. Add pairs naturally with Multiply for linear relationships (slope * x + intercept).",
  subtract: "Computes the difference between two numbers: result = A - B. Subtraction finds differences, calculates relative values, and measures changes. In parametric design, Subtract enables: finding gaps (total - used = remaining), computing offsets from references, calculating deltas between states, or inverting additions. Note the order matters—A - B ≠ B - A—so connect inputs carefully.",
  multiply: "Computes the product of two numbers: result = A × B. Multiplication scales, amplifies, and combines quantities. In parametric design, Multiply enables: scaling factors (dimension * scale), area calculations (width * height), applying percentages (value * 0.5 for half), or building linear relationships. Multiplication distributes over addition: a*(b+c) = a*b + a*c, which is useful for expression simplification.",
  divide: "Computes the quotient of two numbers: result = A / B. Division finds ratios, normalizes, and calculates rates. In parametric design, Divide enables: unit conversion (mm / 1000 = meters), averaging (sum / count), proportion calculations (part / whole), or inverse scaling. Division by zero returns infinity or NaN—protect against this with Clamp or Conditional when B might be zero. Division is the inverse of multiplication.",
  clamp: "Constrains a value to lie within specified minimum and maximum bounds: if value < min, return min; if value > max, return max; otherwise return value unchanged. Clamping is essential for: keeping sliders in valid ranges, preventing impossible geometry (negative dimensions), ensuring numerical stability, or enforcing design constraints. Clamp is more explicit than relying on slider limits—it documents that bounds are intentional and handles edge cases cleanly.",
  min: "Returns the smaller of two values: result = (A < B) ? A : B. Min is useful for: enforcing upper limits (ensure value doesn't exceed threshold), finding the smallest in a pair, taking conservative estimates in uncertainty, or implementing floor operations. Chained Mins find the minimum of multiple values: min(a, min(b, c)) = smallest of a, b, c. Min is commutative and associative.",
  max: "Returns the larger of two values: result = (A > B) ? A : B. Max is useful for: enforcing lower limits (ensure value isn't below threshold), finding the largest in a pair, taking aggressive estimates in uncertainty, or implementing ceiling operations. Chained Maxs find the maximum of multiple values: max(a, max(b, c)) = largest of a, b, c. Max is commutative and associative.",
  expression: "Evaluates mathematical expressions written as text formulas, supporting standard operators (+, -, *, /, ^), parentheses, and common functions (sin, cos, tan, sqrt, abs, floor, ceil, round, min, max, log, exp, pow). Variable names from input ports are substituted into the expression, enabling formulas like 'width * height / 2' or 'sin(angle * 3.14159 / 180)'. Expression is the power tool for complex calculations that would require many separate math nodes. Use when relationships are genuinely complex, but prefer simple nodes for simple operations—they're more readable.",
  scalarFunctions: "Provides a dropdown-selectable collection of standard mathematical functions that take one number in and produce one number out. Available functions include: abs (absolute value), floor (round down), ceil (round up), round (nearest integer), sqrt (square root), sin/cos/tan (trigonometry), asin/acos/atan (inverse trig), log (natural logarithm), exp (e^x), and more. Scalar Functions is more readable than Expression for single-function operations and avoids the need to remember syntax.",
  toggleSwitch: "A manual on/off switch that outputs a boolean value. Use it to gate solver execution, enable previews, or control conditional branches without wiring up external inputs. The switch state is stored as a parameter, making it easy to save workflow presets with different modes.",
  conditional: "Implements if-then-else branching for numeric values: if condition is true (or non-zero), output the True value; otherwise output the False value. Conditional enables: switching between modes (if optimizing then aggressive, else conservative), handling special cases (if zero then default, else computed), implementing piecewise functions, or any decision logic in numeric workflows. The condition input interprets numbers as booleans (0 = false, non-zero = true) or accepts true/false directly.",

  // === LIST OPERATIONS ===
  listCreate: "Constructs a list from individual inputs, collecting values into an ordered sequence. Each input port adds one element; elements are ordered by port position. Lists are fundamental data structures in Numerica: geometry collections (multiple curves), parameter sets (array of radii), measurement series (floor areas). List Create is how you manually assemble such collections. The output list can be processed by all list operations—mapping, filtering, aggregation.",
  listLength: "Returns the count of items in a list as a single number. List Length is essential for: determining array sizes before iteration, validating that inputs have expected counts, computing averages (sum / length), or adapting behavior based on collection size. An empty list has length 0. Length operates in O(1) time—it's a property of the list, not a counting operation.",
  listItem: "Extracts a single element from a list by its index position. Index 0 retrieves the first item, index 1 the second, and so on. Negative indices count from the end: -1 is the last item, -2 is second-to-last. List Item is how you access specific elements when you know which position you need: the first profile for lofting, the maximum value's corresponding geometry, or any random access pattern. Out-of-bounds indices produce errors or empty results.",
  listIndexOf: "Searches a list for a specific value and returns its index position, or -1 if not found. This is membership testing and location finding combined. Use List Index Of to: verify that a value exists in a collection, find where a known item appears, detect duplicates (search for something already added), or implement set-like operations. The search is linear—for large lists, performance scales with list size.",
  listPartition: "Divides a list into groups of specified size, returning a list of lists. A 12-element list partitioned by 4 becomes three lists of 4 elements each. If the list doesn't divide evenly, the final partition contains the remainder. Partitioning is essential for: converting flat arrays to matrices, batching operations into chunks, grouping sequential items, or restructuring data for nested operations. Combined with List Flatten, you can reshape list structures.",
  listFlatten: "Converts a nested list structure into a single flat list by removing layers of nesting. Depth controls how many levels to flatten: depth 1 flattens one level of nesting, depth -1 (or large values) flattens completely. Flattening is essential for: combining results from nested operations, converting matrices to arrays, simplifying list-of-lists into a single sequence, or preparing data for operations that expect flat input.",
  listSlice: "Extracts a contiguous subset of a list from a start index to an end index. The slice includes elements from start up to (but not including) end. Negative indices count from the end. Slicing is essential for: taking the first N items, getting the last N items, extracting middle portions, or windowing through data. Slice creates a new list—the original is unchanged. Combined with List Length, you can compute dynamic slice boundaries.",
  listReverse: "Creates a new list with elements in opposite order: first becomes last, last becomes first. Reversing is essential for: correcting curve direction for lofting, reversing iteration order, mirroring sequences, or creating palindromic patterns. The original list is unchanged—Reverse produces a new list. Reversing twice returns to the original order. List Reverse is O(n) where n is list length.",
  listSum: "Computes the total of all numeric values in a list: result = item[0] + item[1] + ... + item[n]. Sum is the fundamental aggregation operation, essential for: totaling measurements (total floor area), accumulating quantities (material volumes), computing means (sum / count = average), or validating distributions (parts should sum to whole). Empty lists sum to 0. Non-numeric items are typically treated as 0 or cause errors.",
  listAverage: "Computes the arithmetic mean of all numeric values in a list: result = sum / count. Average represents the 'typical' or 'central' value of a distribution. Use for: finding center values, smoothing measurements, summarizing datasets, or normalizing scales. Average is sensitive to outliers—a single extreme value shifts the mean significantly. For outlier-resistant central tendency, use List Median instead.",
  listMin: "Returns the smallest value from a numeric list, essential for finding lower bounds, worst-case scenarios, or threshold triggers. Combined with List Max, you can compute the range (max - min) of a dataset. Use List Min for: finding the lowest point (min Z coordinate), detecting minimum clearances, or identifying the weakest element in a set. Empty lists have no minimum—handle this edge case appropriately.",
  listMax: "Returns the largest value from a numeric list, essential for finding upper bounds, best-case scenarios, or peak detection. Combined with List Min, you can compute the range (max - min) of a dataset. Use List Max for: finding the highest point (max Z coordinate), detecting peak loads, or identifying the strongest element in a set. Empty lists have no maximum—handle this edge case appropriately.",
  listMedian: "Returns the middle value when the list is sorted: for odd-length lists, the center element; for even-length, the average of the two center elements. Unlike average (which every value affects), median is robust to outliers—a single extreme value doesn't shift the median much. Use List Median when: data may contain errors or outliers, you want 'typical' rather than 'mean' value, or for robust statistical analysis.",
  listStdDev: "Computes the standard deviation of a numeric list, measuring how spread out values are from their mean. Low standard deviation means values cluster near the average; high standard deviation means they're dispersed. Use Standard Deviation for: quality control (detecting unusual variation), assessing consistency, statistical analysis, or determining when values are 'close enough' to typical. Standard deviation has the same units as the original values.",

  // === GEOMETRY ANALYSIS ===
  geometryInfo: "Extracts comprehensive information about geometry. Outputs vertex count, face count, edge count, bounding box, center point, surface area, and volume (for closed meshes). Essential for documentation and validation.",
  measurement: "Measures geometric properties: distances, angles, areas, volumes. Connect geometry and select measurement type. Outputs numeric values for downstream calculations.",
  geometryVertices: "Extracts all vertices from geometry as point list. Works on meshes, curves, and surfaces. Use for point-based operations or analysis.",
  geometryEdges: "Extracts edges from geometry as line list. Each edge becomes a line segment. Use for wireframe operations or edge analysis.",
  geometryFaces: "Extracts faces from mesh geometry as individual surfaces or polygons. Use for per-face operations or face filtering.",
  geometryNormals: "Extracts normal vectors from geometry. For meshes, returns face or vertex normals. For surfaces, evaluates surface normals. Use for orientation analysis or offset directions.",
  geometryControlPoints: "Extracts NURBS control points as point list. Only works on NURBS curves and surfaces. Use for direct control point manipulation.",

  // === PROXIMITY & SPATIAL ===
  proximity3d: "Finds nearest geometry/point in 3D space. Input geometry and test point. Outputs closest point, distance, and index. Use for snapping, collision detection, or nearest neighbor queries.",
  proximity2d: "Projects to 2D and finds nearest geometry/point. Works on XY plane. Faster than 3D for planar problems. Outputs closest point and distance in 2D.",
  curveProximity: "Finds closest point on a curve to a test point. Outputs closest curve point, curve parameter (t), and distance. Use for curve snapping or projection operations.",

  // === RANGE & SEQUENCE ===
  range: "Generates a list of numbers from start to end with specified count. Includes both endpoints. Use for parameter sweeps, sampling points, or iteration indices.",
  linspace: "Creates linearly spaced values between start and end. Specify number of samples. Includes endpoints. Similar to range but defines count instead of step.",
  remap: "Remaps a value from one range to another. Input value in [oldMin, oldMax] outputs in [newMin, newMax]. Essential for normalizing or scaling values between different systems.",
  random: "Generates random numbers. Uniform distribution between min and max. Seed parameter for reproducible sequences. Use for variation, noise, or stochastic processes.",
  repeat: "Repeats a value or pattern multiple times. Creates list of repeated elements. Use for array filling, pattern creation, or generating constant lists.",

  // === ARRAY OPERATIONS ===
  linearArray: "Creates copies arranged along a linear direction. Specify count and spacing vector. Use for rows, columns, stairs, or any regular linear pattern.",
  polarArray: "Creates copies arranged in a circular pattern. Specify count, center, axis, and angular extent. Use for radial patterns, gears, wheel spokes, or rotational symmetry.",
  gridArray: "Creates copies arranged in a 2D or 3D grid. Specify counts and spacing for each axis. Use for matrices, waffle structures, or regular 3D lattices.",
  geometryArray: "Applies array transformation to geometry. Combines geometry input with array parameters. Outputs list of transformed geometry instances.",

  // === SIGNAL & WAVE ===
  sineWave: "Generates sine wave value from input parameter. Amplitude, frequency, and phase controls. Use for smooth oscillations, animations, or periodic variations. Output cycles between -amplitude and +amplitude.",
  cosineWave: "Generates cosine wave (sine shifted by 90°). Same parameters as sine. Use when you need to start at peak instead of zero. Often paired with sine for circular motion.",
  sawtoothWave: "Generates sawtooth wave (linear ramp that resets). Creates rising or falling ramps. Use for linear sweeps, progress indicators, or asymmetric oscillations.",
  triangleWave: "Generates triangle wave (linear up then down). Symmetric zigzag pattern. Use for ping-pong animations, symmetric oscillations, or linear interpolation cycles.",
  squareWave: "Generates square wave (alternating high/low). Digital on/off pattern. Use for pulse patterns, binary alternation, or stepped rhythms. Duty cycle controls high/low ratio.",

  // === TRANSFORM NODES ===
  move: "Translates geometry by a vector displacement. Input geometry and translation vector. Output is moved copy. Preserves all geometry properties, only changes position.",
  rotate: "Rotates geometry around an axis by an angle. Specify rotation center, axis direction, and angle in degrees. Use for orientating, spinning, or angular positioning.",
  scale: "Scales geometry from a center point. Uniform or non-uniform scaling with separate XYZ factors. Use for resizing, stretching, or proportional adjustments.",
  fieldTransformation: "Deforms geometry using vector or scalar fields. Points are displaced based on field values at their locations. Falloff controls effect range. Use for organic deformations or field-driven design.",
  movePoint: "Moves a single point by specified XYZ offsets. Simple point translation. Output is displaced point. Use for adjusting individual coordinates.",
  movePointByVector: "Moves a point by a vector displacement. Same as move but specifically for point geometry. Clearer intent when working with points.",
  rotateVectorAxis: "Rotates a vector around an arbitrary axis. Specify axis direction and angle. Use for redirecting vectors, spinning normals, or orbital motion.",
  mirrorVector: "Reflects a vector across a plane defined by normal. Use for bouncing, reflection calculations, or symmetric transformations.",
};

const formatPortLabel = (port: WorkflowPortSpec) => {
  const label = port.label?.trim() || port.key;
  return `${label} (${port.type})`;
};

const formatPortSummary = (
  ports: WorkflowPortSpec[] | undefined,
  label: string,
  maxItems = 3
) => {
  if (!ports || ports.length === 0) return null;
  const entries = ports.map(formatPortLabel);
  const shown = entries.slice(0, maxItems);
  const remaining = entries.length - shown.length;
  const summary =
    remaining > 0 ? `${shown.join(", ")}, +${remaining} more` : shown.join(", ");
  return `${label}: ${summary}`;
};

export const buildNodeTooltipLines = (
  definition?: WorkflowNodeDefinition,
  ports?: { inputs: WorkflowPortSpec[]; outputs: WorkflowPortSpec[] }
) => {
  if (!definition) return [];
  const lines: string[] = [];
  const display = definition.display;
  if (display?.nameEnglish) {
    const romanization = display.romanization ? ` (${display.romanization})` : "";
    lines.push(`${display.nameEnglish}${romanization}`);
  } else if (display?.romanization) {
    lines.push(`(${display.romanization})`);
  }
  if (definition.description) {
    lines.push(definition.description);
  }
  const note = NODE_IMPLEMENTATION_NOTES[definition.type];
  if (note) {
    lines.push(note);
  }
  const inputLine = formatPortSummary(ports?.inputs, "Inputs");
  const outputLine = formatPortSummary(ports?.outputs, "Outputs");
  if (inputLine) lines.push(inputLine);
  if (outputLine) lines.push(outputLine);
  return lines;
};

export const resolveNodeDescription = (definition: WorkflowNodeDefinition) => {
  // Prefer detailed implementation notes over brief built-in descriptions
  const note = NODE_IMPLEMENTATION_NOTES[definition.type];
  if (note) return note;
  // Fall back to built-in description if no implementation note exists
  return definition.description?.trim().length
    ? definition.description
    : "Description pending.";
};

export const getDefaultNodePorts = (definition: WorkflowNodeDefinition) => {
  try {
    const parameters = getDefaultParameters(definition.type);
    return resolveNodePorts(
      { type: definition.type, data: { label: definition.label } },
      parameters
    );
  } catch (error) {
    console.warn("Failed to resolve default ports for documentation", definition.type, error);
    return { inputs: [], outputs: [] };
  }
};
