# Numerica Conventions: Expert Workflow Architecture

## Purpose

This document defines the conventions and architecture for creating production-quality scripts in Numerica. Scripts are not just collections of nodes—they are **thinking tools** that make complex parametric workflows understandable, maintainable, and composable.

**Core Philosophy:**
- **Nodes are UI elements** for thinking about workflows and organizing computation
- **Wires carry typed data** that flows through the system
- **Geometry is information** that grows in shape and complexity as it flows through nodes
- **Inspector nodes reveal data** flowing through wires without mutating it
- **Type system ensures compatibility** - if something doesn't work, it's 90% a type mismatch

---

## 1. Script Authoring Conventions

### 1.1 Layout & Flow

**Left-to-Right Data Flow:**
- Input nodes on the left
- Processing nodes in the middle
- Output nodes on the right
- Data flows left → right through the workflow

**Vertical Organization:**
- Related nodes at similar vertical positions
- Parallel operations stacked vertically
- Sequential operations arranged horizontally

**Spacing & Alignment:**
- Consistent horizontal gaps between stages (100-120px)
- Consistent vertical gaps between parallel nodes (80-100px)
- Align nodes by their centers when possible
- Use groups to visually organize related nodes

### 1.2 Grouping

**Semantic Groups:**
- Group related nodes by function (Inputs, Parameters, Processing, Outputs)
- Groups should tightly fit around their contents with consistent padding (20px)
- Group titles should be descriptive and concise
- Groups can be nested for complex workflows

**Group Sizing:**
- Width: Fit contents + 40px padding (20px each side)
- Height: Fit contents + header + 40px padding
- Groups should not overlap
- Leave space between groups for visual clarity

### 1.3 Naming Conventions

**Node Labels:**
- Descriptive and concise (e.g., "Box Input", "Voxel Resolution", "Mesh Output")
- Use title case for labels
- Avoid redundant prefixes (e.g., "Node 1", "Slider 2")
- Labels should describe the node's purpose, not its type

**Group Labels:**
- Describe the semantic purpose (e.g., "Input Geometry", "Voxelization Parameters", "Output")
- Use title case
- Keep labels short (1-3 words)

**Parameter Names:**
- Use clear, domain-specific names (e.g., "resolution", "padding", "thickness")
- Use camelCase for parameter keys
- Match industry-standard terminology when possible

### 1.4 Slider Placement

**Positioning:**
- Sliders should be positioned **immediately to the left** of the node they control
- Sliders should align with the input port they're connected to
- Leave a small gap (10px) between slider and node
- Sliders should show inline numeric values (no separate number nodes)

**Styling:**
- Use brand-kit colors (golden orange: #f5a623)
- Show current value inline on the slider
- Use appropriate precision for the parameter type

---

## 2. Data Flow & Type System

### 2.1 Port Types

**Geometry Types:**
- `geometry` - Universal geometry type (mesh, nurbs, brep, voxels, etc.)
- Geometry is passed as **ID strings**, not raw objects
- Geometry objects are stored in a central registry and resolved by ID

**Primitive Types:**
- `number` - Numeric values (scalars)
- `vector` - 3D vectors (Vec3)
- `boolean` - True/false values
- `string` - Text values

**Composite Types:**
- `array` - Arrays of any type
- `object` - Key-value objects
- `any` - Accepts any type (used for inspector nodes)

### 2.2 Type Compatibility

**Connection Rules:**
- Ports can only connect if types match
- `any` type accepts connections from any other type
- Geometry subtypes (mesh, nurbs, brep, voxels) all use the `geometry` type
- Type mismatches are prevented by the UI

**Type Coercion:**
- No automatic type coercion
- Use explicit converter nodes when needed
- Type errors are caught at connection time, not runtime

### 2.3 Data Flow Semantics

**Immutability:**
- Nodes do not mutate input data
- Each node produces new output data
- Geometry transformations create new geometry objects

**Evaluation Order:**
- Nodes are evaluated in topological order (dependencies first)
- Cycles are not allowed
- Missing inputs use default values or produce null outputs

**Caching:**
- Node outputs are cached until inputs change
- Geometry objects are cached in the central registry
- Re-evaluation only occurs when necessary

---

## 3. Geometry Taxonomy

### 3.1 Geometry Types

**Mesh Geometry (`type: "mesh"`):**
- Triangulated surface representation
- Properties: `mesh` (RenderMesh), `vertexCount`, `faceCount`, `area_m2`, `volume_m3`, `centroid`
- Subtypes: `regular` (default), `voxels` (from voxel solver)
- Used for: Primitives, boolean operations, voxelized geometry

**Voxel Geometry (`type: "mesh"`, `subtype: "voxels"`):**
- Voxelized representation of geometry
- Generated by voxel solver nodes
- Properties: Same as mesh + `sourceNodeId` (identifies voxel solver)
- Inspector nodes can display voxel positions when `showMeshPositions: true`

**NURBS Curve (`type: "nurbsCurve"`):**
- Parametric curve representation
- Properties: `nurbs` (control points, knots, degree, weights)
- Used for: Curves, paths, profiles

**NURBS Surface (`type: "nurbsSurface"`):**
- Parametric surface representation
- Properties: `nurbs` (control point grid, knots U/V, degrees U/V, weights)
- Used for: Smooth surfaces, lofts, sweeps

**BRep Geometry (`type: "brep"`):**
- Boundary representation (solid modeling)
- Properties: `brep` (vertices, edges, faces), `mesh` (tessellated representation)
- Used for: Solid modeling, boolean operations, complex shapes

**Vertex Geometry (`type: "vertex"`):**
- Single point in 3D space
- Properties: `position` (Vec3)
- Used for: Points, control points, markers

**Polyline Geometry (`type: "polyline"`):**
- Connected sequence of line segments
- Properties: `vertexIds` (array of vertex IDs), `closed` (boolean)
- Used for: Paths, outlines, profiles

### 3.2 Geometry Properties

**Common Properties (all geometry types):**
- `id` - Unique identifier (string)
- `type` - Geometry type (union of all types)
- `layerId` - Layer assignment (string)
- `sourceNodeId` - Node that created this geometry (optional)
- `metadata` - Custom key-value data (optional)

**Mesh-Specific Properties:**
- `mesh` - RenderMesh (positions, normals, uvs, indices)
- `primitive` - Primitive info (kind, dimensions) for primitive shapes
- `subtype` - Mesh classification ("voxels" | "regular")
- `vertexCount` - Number of vertices (computed from mesh)
- `faceCount` - Number of faces (computed from mesh)

**Physical Properties (when applicable):**
- `area_m2` - Surface area in square meters
- `volume_m3` - Volume in cubic meters
- `centroid` - Center of mass (Vec3)
- `mass_kg` - Mass in kilograms (requires material)
- `thickness_m` - Thickness in meters (for surfaces)
- `inertiaTensor_kg_m2` - Inertia tensor (for solids)

### 3.3 Adding New Geometry Types

**To add a new geometry type:**

1. **Define the type in `types.ts`:**
   ```typescript
   export type MyGeometry = {
     id: string;
     type: "myType";
     layerId: string;
     myData: MyDataStructure;
     sourceNodeId?: string;
     metadata?: Record<string, unknown>;
   };
   ```

2. **Add to the Geometry union:**
   ```typescript
   export type Geometry = 
     | VertexGeometry
     | PolylineGeometry
     | MeshGeometry
     | MyGeometry  // <-- Add here
     | ...;
   ```

3. **Update the data inspector (`dataInspect.ts`):**
   ```typescript
   const formatGeometry = (g: Geometry, ctx: Required<InspectContext>): string[] => {
     const lines: string[] = [];
     lines.push(`Geometry: ${g.type}`);
     
     if (g.type === "myType") {
       // Format myType-specific properties
       lines.push(`  myProperty: ${g.myData.property}`);
     }
     
     // ... rest of formatting
   };
   ```

4. **Create node definitions** that produce/consume the new type
5. **Update port type definitions** if needed
6. **Test with inspector nodes** to verify data display

---

## 4. Inspector Nodes (Panel & TextNote)

### 4.1 Purpose

**Inspector nodes are universal data viewers:**
- Connect to **any node's output** to see what data is flowing
- Automatically format data based on type
- Never mutate upstream data
- Essential debugging and documentation tools

**Use Cases:**
- Debugging workflows (inspect intermediate results)
- Documenting scripts (show example outputs)
- Monitoring solver progress (display iteration counts, errors)
- Displaying geometry metadata (vertex counts, areas, volumes)

### 4.2 Panel Nodes

**Characteristics:**
- Read-only data viewer
- Built-in scrolling for long lists
- Monospace font for structured data
- Default `maxLines: 200`

**Best For:**
- Large datasets (hundreds of lines)
- Structured data (arrays, objects)
- Geometry metadata inspection
- Solver output monitoring

**Parameters:**
- `maxLines` - Maximum lines to display (default: 200)
- `showIndex` - Show line indices (default: true)
- `indexStart` - Starting index (default: 0)
- `indent` - Indentation level (default: 2)
- `showMeshPositions` - Show voxel/mesh positions (default: false)

### 4.3 TextNote Nodes

**Characteristics:**
- Data viewer + pass-through
- Can add custom text/annotations
- Resizable (drag bottom-right corner)
- Scrolling support for long lists
- Default `maxLines: 50`

**Best For:**
- Annotated data (add context to outputs)
- Documentation (explain workflow stages)
- Medium-sized datasets (tens of lines)
- Inline comments and notes

**Parameters:**
- `text` - Fallback text when no input connected
- `maxLines` - Maximum lines to display (default: 50)
- `showIndex` - Show line indices (default: true)
- `showMeshPositions` - Show voxel/mesh positions (default: false)
- `indexStart` - Starting index (default: 0)
- `indent` - Indentation level (default: 0)

### 4.4 Data Formatting

**Automatic Type Detection:**
- **Geometry** → Formatted with metadata (type, vertexCount, faceCount, area, volume, etc.)
- **Numbers** → Formatted with appropriate decimals
- **Vectors** → Formatted as `Vec3 (x, y, z)`
- **Booleans** → Displayed as "true" or "false"
- **Strings** → Displayed as-is (with line wrapping)
- **Arrays** → Formatted as indexed lists
- **Objects** → Formatted as key-value pairs

**Geometry Formatting:**
```
Geometry: voxels
  id: mesh-1738123456-0
  layerId: layer-default
  vertexCount: 125
  faceCount: 250
  area_m2: 12.5
  volume_m3: 3.75
  centroid: (1.5, 2.3, 0.8)
  sourceNodeId: node-voxelSolver-123
```

**Voxel Position Display (when `showMeshPositions: true`):**
```
Geometry: voxels
  ...
  positions (showing 20 of 125):
    0: (0.0, 0.0, 0.0)
    1: (1.0, 0.0, 0.0)
    2: (2.0, 0.0, 0.0)
    ...
    ... (105 more)
```

### 4.5 Scrolling Behavior

**Panel Nodes:**
- Automatic scrolling when content exceeds visible area
- Scroll with mouse wheel/trackpad over panel content area
- Scroll state persists per node
- Scroll resets when content changes

**TextNote Nodes:**
- Same scrolling behavior as panel nodes
- Scroll with mouse wheel/trackpad over note content area
- Scroll state persists per node
- Resizing affects visible line count

---

## 5. Saved Scripts

### 5.1 Script Structure

**A production-quality script includes:**
1. **Input nodes** - Geometry sources, parameters
2. **Processing nodes** - Transformations, solvers, operations
3. **Output nodes** - Results, visualizations
4. **Inspector nodes** - Documentation, debugging
5. **Groups** - Semantic organization
6. **Edges** - Data flow connections

**Example: Voxel Solver Script**
```
[Input Geometry Group]
  - Width Slider → Box Node
  - Height Slider ↗
  - Depth Slider ↗

[Voxelization Parameters Group]
  - Resolution Slider → Voxel Solver Node → Mesh Node
  - Padding Slider ↗
  - Mode Slider ↗
  - Thickness Slider ↗
  - IsoValue Slider ↗

[Output]
  - TextNote Node (connected to Mesh Node, shows voxel data)
```

### 5.2 Script Conventions

**Node Placement:**
- Sliders immediately left of nodes they control
- Groups tightly fit around contents
- Consistent spacing between groups
- Clear left-to-right flow

**Edge Connections:**
- All necessary edges included in saved script
- No dangling nodes (all nodes connected or intentionally isolated)
- Inspector nodes connected to relevant outputs
- Clear data flow paths

**Parameters:**
- Sensible default values
- Appropriate ranges (min/max)
- Correct precision for numeric parameters
- Inspector nodes configured correctly (`showMeshPositions: true` for voxels)

**Documentation:**
- TextNote nodes explain workflow stages
- Group labels describe semantic purpose
- Node labels are descriptive
- Example outputs shown in inspector nodes

### 5.3 Script Testing

**Before saving a script:**
1. **Test all parameter ranges** - Verify min/max values work
2. **Test edge cases** - Empty inputs, extreme values, null inputs
3. **Verify inspector nodes** - Check data display is correct
4. **Test workflow evaluation** - Ensure all nodes evaluate correctly
5. **Check visual layout** - Groups fit, spacing is consistent
6. **Verify persistence** - Save, reload, verify all connections intact

---

## 6. Voxel Solver: A Case Study

### 6.1 Why Voxels Are a Geometry Type

**Voxels are not "just a mesh":**
- Voxels represent a **discretized spatial field**
- Each voxel is a point in a regular 3D grid
- Voxels have semantic meaning (density, occupancy, distance field)
- Voxel geometry is generated by a specific algorithm (voxel solver)

**Classification:**
- `type: "mesh"` - Voxels are rendered as mesh geometry
- `subtype: "voxels"` - Distinguishes voxels from regular meshes
- `sourceNodeId` - Identifies the voxel solver that created them

**Why This Matters:**
- Inspector nodes can detect voxel geometry and format it appropriately
- Users can distinguish voxel data from regular mesh data
- Downstream nodes can handle voxels differently if needed
- Debugging is easier when geometry types are explicit

### 6.2 Voxel Solver Workflow

**Input:**
- Any geometry type (box, sphere, cylinder, custom mesh, etc.)
- Voxelization parameters (resolution, padding, mode, thickness, isoValue)

**Processing:**
1. Build voxel grid from input geometry
2. Compute density field (solid or surface mode)
3. Extract isosurface at specified isoValue
4. Generate mesh from voxel grid

**Output:**
- Mesh geometry with `subtype: "voxels"`
- `sourceNodeId` set to voxel solver node ID
- Mesh contains voxel positions as vertices

**Inspector Integration:**
- Connect TextNote or Panel to voxel solver output
- Set `showMeshPositions: true` to display voxel coordinates
- Inspector detects voxel geometry and labels it as "voxels"

### 6.3 Lessons Learned

**What Worked:**
1. **Semantic grouping** - Input, Parameters, Output groups make workflow clear
2. **Slider placement** - Sliders left of nodes, aligned with inputs
3. **Inspector nodes** - TextNote shows voxel data, documents output
4. **Type system** - Any geometry input works (box, sphere, etc.)
5. **Data flow** - Clear left-to-right progression

**What Didn't Work Initially:**
1. **No geometry generation** - First script didn't create actual geometry
2. **Unorganized layout** - Nodes scattered, no clear flow
3. **Missing connections** - Inspector nodes not connected to outputs
4. **Wrong parameters** - `showMeshPositions: false` prevented voxel display
5. **No documentation** - No TextNote nodes explaining workflow

**Final Result:**
- Fully functional voxel solver script
- Clear visual organization with groups
- Inspector nodes show voxel data
- Sliders control all parameters
- Works with any input geometry
- Saved as canonical example script

---

## 7. Common Debugging Workflow

### 7.1 When Something Doesn't Work

**Step 1: Check Type Compatibility**
- Are the port types compatible?
- Is the connection allowed by the type system?
- 90% of issues are type mismatches

**Step 2: Inspect Data Flow**
- Add a Panel or TextNote node
- Connect it to the problematic node's output
- Check what data is actually flowing
- Look for null values, wrong types, unexpected formats

**Step 3: Check Node Parameters**
- Are parameters set correctly?
- Are ranges appropriate (min/max)?
- Are default values sensible?
- Are required parameters missing?

**Step 4: Check Geometry**
- Is geometry being generated?
- Does geometry have the expected properties?
- Is `sourceNodeId` set correctly?
- Is geometry type correct?

**Step 5: Check Evaluation Order**
- Are dependencies satisfied?
- Are there cycles in the graph?
- Are nodes being evaluated in the correct order?

### 7.2 Using Inspector Nodes for Debugging

**Add Panel nodes at key points:**
- After input nodes (verify inputs are correct)
- After processing nodes (verify transformations worked)
- Before output nodes (verify final results)

**Check Geometry Metadata:**
- Connect Panel to geometry output
- Verify `vertexCount`, `faceCount`, `area_m2`, `volume_m3`
- Check `sourceNodeId` to trace geometry origin
- Look for `subtype` to identify geometry classification

**Check Intermediate Values:**
- Connect Panel to numeric outputs
- Verify calculations are correct
- Check for NaN, Infinity, or unexpected values

---

## 8. Best Practices Summary

### 8.1 Script Creation

✅ **DO:**
- Use semantic groups to organize nodes
- Place sliders immediately left of nodes
- Use clear, descriptive labels
- Include inspector nodes for documentation
- Test all parameter ranges
- Verify all connections before saving
- Use consistent spacing and alignment

❌ **DON'T:**
- Scatter nodes randomly
- Use generic labels ("Node 1", "Slider 2")
- Leave inspector nodes disconnected
- Save scripts without testing
- Overlap groups or nodes
- Use inconsistent spacing

### 8.2 Data Flow

✅ **DO:**
- Follow left-to-right flow
- Use type system to prevent errors
- Add inspector nodes at key points
- Document complex workflows with TextNote nodes
- Use appropriate geometry types

❌ **DON'T:**
- Create cycles in the graph
- Ignore type mismatches
- Assume data is correct without inspecting
- Mix geometry types without converters
- Mutate input data

### 8.3 Geometry Handling

✅ **DO:**
- Use appropriate geometry types for the task
- Set `sourceNodeId` for generated geometry
- Use `subtype` to classify mesh variants (voxels, etc.)
- Inspect geometry metadata with Panel nodes
- Understand geometry properties (vertexCount, area, volume)

❌ **DON'T:**
- Assume all meshes are the same
- Ignore geometry metadata
- Skip geometry validation
- Use wrong geometry types for operations

### 8.4 Inspector Nodes

✅ **DO:**
- Use Panel for large datasets
- Use TextNote for documentation
- Set `showMeshPositions: true` for voxels
- Configure `maxLines` appropriately
- Use scrolling for long lists

❌ **DON'T:**
- Leave inspector nodes disconnected
- Use default parameters for all cases
- Ignore data formatting options
- Forget to enable scrolling for long lists

---

## 9. Conclusion

**Numerica's power comes from its semantic architecture:**
- **Typed data flow** ensures compatibility
- **Geometry as information** enables parametric design
- **Inspector nodes** reveal what's happening
- **Composable workflows** enable complex designs
- **Clear conventions** make scripts maintainable

**When creating scripts:**
1. Think semantically (what does each stage do?)
2. Organize visually (groups, spacing, alignment)
3. Document thoroughly (TextNote nodes, clear labels)
4. Test rigorously (all parameters, edge cases)
5. Inspect data flow (Panel nodes at key points)

**The result:**
- Scripts that are easy to understand
- Workflows that are easy to modify
- Designs that are easy to iterate
- Systems that are easy to debug

**This is the Numerica way.** ✨

---

## Related Documents

- **[numerica_data_types.md](./numerica_data_types.md)** - Comprehensive reference for all port types, data structures, and inspector display formats
